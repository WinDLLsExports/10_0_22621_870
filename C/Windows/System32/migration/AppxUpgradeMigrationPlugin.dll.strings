 A^_^
 A^A\_
 A_A^_
 A_A^_^]
 A_A^A\
 A_A^A]A\_
 A_A^A]A\_^]
 H3E H3E
 http://www.microsoft.com/windows0
 Microsoft Corporation. All rights reserved.
 Operating System
 Windows
!(wil::verify_bool(CopyFileW(srcPath.GetChars(), destPath.GetChars(), 0)))
!(wil::verify_bool(hKeepRunningThread))
!(wil::verify_bool(QueryServiceStatus(service.get(), &serviceStatus)))
!(wil::verify_bool(versionSize > 0))
!]_0t
!0H!t$pI
!This program cannot be run in DOS mode.
!TkjE
!v0I&
"m!u4W
"Microsoft Window
"system" applyFilter="Yes">
"user">
#HMDuV
$Microsoft Ireland Operations Limited1
%|fUN<
%CSIDL_LOCAL_APPDATA%\Microsoft\Windows\Notifications
%CSIDL_LOCAL_APPDATA%\Packages\$\SystemAppData
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%u)\%hs!%p: 
%ls file does not exist
%ls file exists
%ls for user %ls is known to CapAuth
%ls for user %ls isn't known to CapAuth (needs Registration)
%ls is in plugin PackagesToRemove key. Skip preregister
%ls key not found, skipping GatherDataForProcessAllUserStorePackages
%ls not found yet, filling entry
%ls service status = 0x%x
%ls: %ls
%ls\%ls%ls
%Microsoft Windows Production PCA 2011
%Microsoft Windows Production PCA 20110
%ProgramData%\Microsoft\Windows\AppRepository
%ProgramData%\Microsoft\Windows\AppRepository\CheckPoint.VPN_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\f5.vpn.client_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\FileManager_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\JuniperNetworks.JunosPulseVpn_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\Microsoft.MoCamera_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\SonicWALL.MobileConnect_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\windows.immersivecontrolpanel_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\winstore_*_cw5n1h2txyewy.xml
%PROGRAMDATA%\Microsoft\Windows\AppxProvisioning.xml
%ProgramFiles%\WindowsApps\
%s\%s
%s_%s_%s_%s
%SystemRoot%\System32\
%WINDIR%\System32\AppxProvisioning.xml
&go`4
&S|9a
(_^][
(A^_^[
(caller: %p) 
(Default)
(lastError != ERROR_FILE_NOT_FOUND)
(packageBundle->bundleFullName.GetLength() > 0)
(packageBundle->mainPackageFullName.GetLength() > 0)
)Microsoft Root Certificate Authority 20100
)onecore\base\appmodel\runtime\src\systemmetadatainternal.cpp
*cursor == L'\0'
*isPackageEndOfLife
,45rTznX0lCJdFgP1NgKPJscHxGueerKGk4X4KXxqhMU=0Z
,7K|\
... Package %ls is all-user installed so no need to write its upgrade key
... Package %ls is being end of lifed so it's being written to the EndOfLife key
... Package %ls is dev mode. Writing to upgrade keys
... Package %ls is LOB so no need to write its upgrade key
... Package %ls is NOT being end of lifed so it's being written to the Downlevel Installed key
... Package %ls is not installed. Nothing to do
... Package %ls is OEM so no need to write its upgrade key
... Package's root is %ls
... Unable to process recovery info for package 0x%x. Assume this app is fully on system volume
.?AVexception@@
.?AVResultException@wil@@
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.data
.data$brc
.data$r$brc
.edata
.gehcont
.gfids
.giats
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.L9u8t7L
.pdata
.rdata
.rdata$brc
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.recovery
.rsrc$01
.rsrc$02
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.xdata
.xdata$x
.xn--
/OfflineSoftwareHive:"
:%|fUu=
:TOC8uJD9B
:Tt3n
?/=KzdN
??0exception@@QEAA@AEBV0@@Z
??0exception@@QEAA@XZ
??1exception@@UEAA@XZ
??1type_info@@UEAA@XZ
?terminate@@YAXXZ
@.data
@.reloc
@.rsrc
@8|$@t
@8y(t
@A^_]
@A^_^
@A^_^[]
@A_A^_
@A_A^_^]
@A_A^A\_^
@A_A^A]_^
@A_A^A]A\_
@A_A^A]A\_^]
@FamilyName
@FullName
@IsLOBApp
@PackageType
@ProvisionSourceIsBundle
@SUVWATAUAVAWH
@SUVWATAVAWH
@SUVWAVAWH
@UAVAWH
@USVWATAUAVAWH
@USVWATAUAWH
@USVWATAVAWH
@USVWATH
@USVWAUAVAWH
@USVWAUAVH
@USVWAVAWH
@USVWAVH
@USVWH
@USWH
@UVWATAUAVAWH
@UVWAVAWH
@UVWH
@UWAVH
@VWATAVAWH
@VWAVH
@WAVAWH
[%hs(%hs)]
[%hs]
[Desktop Only] Failed to find cellular modem in the descover phase.
[Desktop Only]Package family %ls is end-of-lifed
\$ E3
\$ UH
\$ UVW
\$ UVWAVAWH
\$ UVWH
\$hH!EHH
\* [*]</pattern>
\*.xml
\\?\UNC\
\Applications\
\AppxManifest.xml
\AppxMetadata\AppxBundleManifest.xml
\Autogen
\Frameworks\
\InfusedApps
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
\MgRich
\microsoft.system.package.metadata
\Microsoft\Windows\AppxDeploymentClient
\OSRollbackPackages.txt
\Packages\
\PluginExecutedFixStateRepository
\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts
\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths
\zV&8
]</pattern>
]HD8}8
__C_specific_handler
__CxxFrameHandler3
__dllonexit
_amsg_exit
_Classes
_CxxThrowException
_initterm
_lock
_onexit
_purecall
_unlock
_vsnprintf_s
_vsnwprintf
_wcsicmp
_wcsnicmp
_XcptFilter
` UAVAWH
`.rdata
`0^0\
`A^_^[]
`A_A^]
`A_A^_^]
`A_A^A\^]
`A_A^A]A\_^]
{ ATAVAWH
{OX,*
|$ AVH
|$1D8
|$A@8
|$DE3
|$hA;
|$hE3
|$PE3
|$XE3
}0H+}(H
}bwu=
}gfD9}o
}HD8}8
~(D8n8t@H
</objectSet></exclude>
</objectSet></include>
</objectSet></locationModify>
</objectSet></merge>
</objectSet></unconditionalExclude>
</rules></migXml>
<?xml version="1.0" encoding="utf-8"?><xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:element name="AppxProvisionList">  <xs:complexType>    <xs:all>      <xs:element name="EndOfLife" type="CT_EndOfLife" minOccurs="0"/>      <xs:element name="Provisioned" type="CT_Provisioned" minOccurs="0"/>    </xs:all>  </xs:complexType>  <xs:unique name="Package_FamilyName">    <xs:selector xpath="m:EndOfLife/m:Package"/>    <xs:field xpath="@FamilyName"/>  </xs:unique>  <xs:unique name="Package_FullName">    <xs:selector xpath="m:Provisioned/m:Package"/>    <xs:field xpath="@FullName"/>  </xs:unique></xs:element><xs:complexType name="CT_EndOfLife">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FamilyName" type="ST_FamilyName" use="required"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:complexType name="CT_Provisioned">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FullName" type="ST_FullName" use="required"/>        <xs:attribute name="PackageType" type="ST_PackageType"/>        <xs:attribute name="ProvisionSourceIsBundle" type="xs:boolean"/>        <xs:attribute name="IsLOBApp" type="xs:boolean"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:simpleType name="ST_FamilyName">  <xs:restriction base="xs:string">    <xs:minLength value="17"/>    <xs:maxLength value="64"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_FullName">  <xs:restriction base="xs:string">    <xs:minLength value="30"/>    <xs:maxLength value="127"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_PackageType">  <xs:restriction base="xs:string">    <xs:enumeration value="resource"/>    <xs:enumeration value="framework"/>    <xs:enumeration value="bundle"/>  </xs:restriction></xs:simpleType></xs:schema>
<@/t5L
<@\t=fB
<A\t.H
<exclude><objectSet>
<include><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%ProgramFiles%\WindowsApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime&apos;)"><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%windir%\InfusedApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime\InfusedApps&apos;)"><objectSet>
<merge script="MigXmlHelper.DestinationPriority()"><objectSet>
<merge script="MigXmlHelper.SourcePriority()"><objectSet>
<migXml xmlns=""><rules context=
<P/u(
<pattern type="File">
<pattern type="Registry">
<String too big>
<Task xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">            <RegistrationInfo>                <SecurityDescriptor>D:(A;;GA;;;SY)(A;;FRFX;;;LS)(A;;FA;;;BA)</SecurityDescriptor>            </RegistrationInfo>            <Principals>                <Principal id="LocalSystem">                    <UserId>S-1-5-18</UserId>                </Principal>            </Principals>            <Triggers>                <TimeTrigger>                    <Repetition>                        <Interval>PT8H</Interval>                        <StopAtDurationEnd>false</StopAtDurationEnd>                    </Repetition>                    <StartBoundary>2017-01-01T00:00:00Z</StartBoundary>                    <Enabled>true</Enabled>                    <RandomDelay>PT8H</RandomDelay>                </TimeTrigger>            </Triggers>            <Settings>                <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>                <DisallowStartIfOnBatteries>true</DisallowStartIfOnBatteries>                <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>                <AllowHardTerminate>false</AllowHardTerminate>                <StartWhenAvailable>true</StartWhenAvailable>                <RunOnlyIfNetworkAvailable>true</RunOnlyIfNetworkAvailable>                <AllowStartOnDemand>true</AllowStartOnDemand>                <Enabled>true</Enabled>                <Hidden>false</Hidden>                <RunOnlyIfIdle>true</RunOnlyIfIdle>                <WakeToRun>false</WakeToRun>                <Priority>8</Priority>                <UseUnifiedSchedulingEngine>true</UseUnifiedSchedulingEngine>            </Settings>            <Actions Context="LocalSystem">                <Exec>                    <Command>%windir%\system32\rundll32.exe</Command>                    <Arguments>%windir%\system32\AppxDeploymentClient.dll,ScheduleAppInstallerBackgroundUpdate</Arguments>                </Exec>            </Actions>        </Task>
<unconditionalExclude><objectSet>
>ARI8u!A
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>NGdx
040904B0
0A^_]
0A^_^
0A^A\_
0A_A^_
0A_A^_^]
0A_A^A\_^
0A_A^A]A\_
0A_A^A]A\_^]
0x%x: Could not get path to provisioning XML -- not performing EOL and provisioned-package cleanup
1(0&0
1/0-0
10.0.22621.870
10.0.22621.870 (WinBuild.160101.0800)
111019184142Z
1234567890abcdefghjkmnpqrstvwxyzABCDEFGHJKMNPQRSTVWXYZ
1Z6Ri
20221008013800.448Z0
20221008085420Z
20221009085420Z0w0=
210930182225Z
211202190522Z
220505192315Z
229879+4700220
230228190522Z0
230504192315Z0p1
261019185142Z0
300930183225Z0|1
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
5@8}PtZH
5fD9n
7%k'`
8\$@A
8A^_^[
9A98uCA9x
9N4t\A
9N4tN
9O4t?A
9O4t>
9O4tN
a tSH
A,9A(
A\_^[]
A^_^[]
A^A]]
A^A]_^[]
A^A]A\_]
A_A]A\_]
A_A]A\_^[]
A_A^]
A_A^_
A_A^_^[]
A_A^_^]
A_A^A\
A_A^A\^]
A_A^A\_]
A_A^A\_^[]
A_A^A\_^][
A_A^A]_]
A_A^A]_^[]
A_A^A]A\]
A_A^A]A\_
A_A^A]A\_[]
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
A8_0t
A8_1u
A8_2u
A8}0t
A9~0u
A9u0t)H!|$pH
About to call ResetPluginTimer.
AcquireSRWLockExclusive
AcquireSRWLockShared
AddPackageRegistryKeyToArray(fullName, &bundleFullNames)
AddPackageRegistryKeyToArray(fullName, &packageFullNames)
AddUplevelPackageToDelete(subKey, keysToDelete)
ADVAPI32.dll
allUserApplicationsKey.CopyTree(packageToWrite, mainPackageKey)
allUserApplicationsKey.DeleteSubKeyTree(keysToDelete[i]->GetChars())
allUserApplicationsKey.OpenIfExists(HKEY_LOCAL_MACHINE, allUserStoreApplicationsPath.GetChars(), KEY_READ)
allUserApplicationsKey.OpenSubKey(allUserPackageFullName, KEY_READ, &downlevelAllUserPackageKey)
allUserApplicationsKey.OpenSubKey(subKey, KEY_READ, &mainPackageKey)
allUserApplicationsKey.SetUInt32Value(regIuiPolicyCheckedString, 1)
allUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &deprovisionedKey)
allUserStoreKey.GetKeySecurity(DACL_SECURITY_INFORMATION, allUserStoreSD)
allUserStoreKey.Open( HKEY_LOCAL_MACHINE, effectiveAllUserStorePath, KEY_READ | KEY_WRITE | WRITE_DAC)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, allUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, offlineAllUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.OpenSubKey( s_Applications, KEY_READ | KEY_WRITE | WRITE_DAC, &allUserApplicationsKey)
allUserStoreKey.OpenSubKey( s_EndOfLife, KEY_READ | KEY_WRITE | WRITE_DAC, &endOfLifeKey)
allUserStoreKey.OpenSubKey( s_Staged, KEY_READ | KEY_WRITE | WRITE_DAC, &stagedKey)
allUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &allUserStagedKey)
allUserStoreKey.OpenSubKey(userSid, KEY_READ, &userKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::allUserApplicationsString, KEY_READ, &allUserApplicationsKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::inboxApplicationsString, KEY_READ, &inboxApplicationsKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::stagedApplicationsString, KEY_READ, &stagedKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::upgradeApplicationsString, KEY_READ, &upgradeKey)
allUserStoreKey->OpenSubKey(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
api-ms-win-appmodel-runtime-l1-1-1.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-heap-obsolete-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-libraryloader-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-version-l1-1-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-security-provider-l1-1-0.dll
api-ms-win-security-sddl-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
AppDataVolumeKey
AppDataVolumeName
AppDB
appdb.dat
AppendPackagePathAndApplyTrustLabel(offlinePackagePath.GetChars(), applicationPath, offlineSoftwareHive, cmdLineBuilder)
APPID
AppInstallerUpdater
Applications
applicationsKey.GetUInt32Value(appxUpgradeNeededValueName, &appxUpgradeNeededValue)
applicationsKey.GetUInt32Value(noReRegisterOnUpgradeValueName, &noReRegisterOnUpgradeValue)
applicationsKey.GetUInt64Value(downlevelOSVersionValueName, &this->downlevelOSVersion)
applicationsKey.SetUInt32Value(appxUpgradeNeededValueName, this->appxUpgradeNeeded ? 1 : 0)
applicationsKey.SetUInt32Value(noReRegisterOnUpgradeValueName, this->noReRegisterOnUpgrade ? 1 : 0)
applicationsKey.SetUInt64Value(downlevelOSVersionValueName, this->downlevelOSVersion)
applicationsPathBuilder.AppendString(Common::Deployment::applicationsDir)
applicationsPathBuilder.AppendString(infusedAppsFolder.GetChars())
Applying downlevel stub preference %d for package %ls
ApplySuccessFailed
ApplyTrustLabel(cmdLineBuilder.GetChars())
ApplyTrustLabelToPackages failed 0x%x
ApplyTrustLabelToPackagesUnderRegistryKey(&packageFamilyKey, applicationPath, offlineSoftwareHive, cmdLineBuilder)
ApplyTrustOffline.exe
AppModelPackageRepository
AppModelRoot
AppReadiness
AppsEOL
Appx Migration Plugin called RtlGetDeviceFamilyInfoEnum: downlevelOSVersion=0x%llx
Appx Migration Plugin called SRCheckIntegrity(%ls): Entrypoint not found (0x%x)
Appx Migration Plugin called SRCheckIntegrity(%ls): Module (%ls) not present
Appx Migration Plugin called SRCheckIntegrity(%ls): Module not loaded (0x%x)
Appx Migration Plugin version number is %d.%d.%d.%d
Appx Migration Plugin will not perform re-registration of Packages (OSupgradeInPlace)
Appx Migration Plugin will perform re-registration of Packages (OSswap)
Appx Upgrade Migration Plugin
AppX*
AppxAllUserStore
AppxAllUserStore::GetAllUserApplicationsFullPath(&allUserStoreApplicationsPath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePathBuffer)
AppxAllUserStore::GetEndOfLifeApplicationsFullPath(&endOfLifePath)
AppxAllUserStore::GetInboxApplicationsFullPath(&inboxPackagesBuffer)
AppxAllUserStore::GetStagedApplicationsFullPath(&allUserStoreStagedPath)
AppxAllUserStore::GetUpgradeApplicationsFullPath(&upgradePath)
AppxAllUserStore::SetPackageOverrideSetupPhaseHelper(packageFamilyName.GetChars(), AppxAllUserStore::c_setupPhase_PostShell)
AppxCleanupOrphanPackages
AppxCleanupOrphanPackages()
AppxCleanupSystemAppsMigratedToFOD
AppxCleanupSystemAppsMigratedToFOD()
AppxDeploymentClient.dll
AppxDestagePackage
appxFactory->CreateBundleManifestReader(manifestStream.Get(), bundleManifestReader.GetAddressOf())
AppxManifest.xml
AppxMetadata\AppxBundleManifest.xml
AppxPackageVolumes
AppxPreRegisterAllInboxPackages
AppxPreRegisterAllInboxPackages failed: 0x%x
AppxPreRegisterPackage
AppxProvisioning.xml not found in programdata folder, trying system32 location
AppxProvisionList
AppxRoot
AppxStateChange
AppxSvc
AppxUpgradeMigration discontinuing plug-in timeout extension.
AppxUpgradeMigration executing longer than expected.
AppXUpgradeMigration exiting.
AppXUpgradeMigration signaling extension thread.
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL %lu
AppxUpgradeMigration::AppxUpgradeMigration: failed reading EOL reg vaue
AppxUpgradeMigration::AppxUpgradeMigration: Failed to write cellular already EOL reg key value
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: CLSIDFromString error = %8.8X
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Enter
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Exit
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed DevObjOpenDevRegKey error = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed NetCfgInstanceId error = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Failed to write cellular reg key value
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Failed to write cellular reg key value in the uplevel OS
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: found only one interface, skipping check
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Found wireless WAN
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: foundCellularModem = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: has modem = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: index = %lu
AppxUpgradeMigration::Discover called
AppxUpgradeMigration::Discover done (0x%x)
AppxUpgradeMigration::FoundCellularModemInstalled: failed to find a modem from the 'gather' phase
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from a prior run = %lu.
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from the 'gather' phase
AppxUpgradeMigration::FoundCellularModemInstalled: value doesn't exist
AppxUpgradeMigration::Gather called
AppxUpgradeMigration::IsWirelessWanInterfaceType ConvertInterfaceGuidToLuid error = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType GetIfEntry2 error = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.MediaType = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.PhysicalMediumType = %lu
AppxUpgradeMigration:EOL-Messaging/MobilePlans
AppxUpgradeMigrationPlugin.dll
APPXUPGRADEMIGRATIONPLUGIN.dll
AppxUpgradeMigrationPlugin.dll
AppxUpgradeMigrationPlugin.pdb
AppxUpgradeNeeded
arm64
as.,k{n?,
ATAVAWH
ATL$__a
ATL$__m
ATL$__z
AutoCheckIntegrity
Autogen
autogenDirectoryPath.SetValueFromString(this->singleInstanceStore.GetChars())
backupManifestPathBuilder.AppendString(backupManifestDir.GetString())
backupManifestPathBuilder.AppendString(L".xml")
backupManifestPathBuilder.AppendString(L"\\")
backupManifestPathBuilder.AppendString(package)
bstrOnlineFilePath.CopyFromString(onlineFilePath)
bstrOnlineRegistryPath.CopyFromString(onlineRegistryPathBuffer.GetChars())
bstrPath.CopyFromString(path.GetChars())
bstrSisPath.CopyFromString(sisPath)
bundle
Bundle
Bundle %ls is being written to the downlevel installed key
bundleAndMainPackage->bundle.SetValueFromString(packageFullName)
bundleAndMainPackage->mainPackage.SetValueFromString(packageFullName)
BundleFullName
bundleInfoRootKey.CreateSubKey(bundleFullName, KEY_READ | KEY_WRITE, &bundleKey)
bundleInfoRootKey.OpenSubKey(bundleFullName, KEY_READ, &bundleKey)
bundleKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
bundleKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
BundleManifestInfo
bundleManifestReader->GetPackageInfoItems(&packages)
bundlesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
BX9A4t
C @8}Wu
C9fD9?u0
callContext
CallContext:[%hs] 
Calling ApplyTrustLabel
Calling DeleteOSRollbackPackagesRegistry
Calling SavePackageListFromFileToRegistry
CallRtlGetDeviceFamilyInfoEnumIfFunctionAvailable(nullptr, &deviceFamily, nullptr)
Cannot find package %ls in SIS, not writing to Staged Key
cD8|$0t9I
CellularAppsRemoved
cfD9}o
Checking downlevel installed package for the user %ls and package %ls
CheckOrFixStateRepositoryViaExport called to %ls
CheckOrFixStateRepositoryViaExport done %ls. Disposition: %d
CheckRepository(Fix) reports Disposition=%d, #ErrorsCorrected=%I64u
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
Cleaning up orphan packages from downlevel OS
Cleaning up SystemApps migrated to FOD
Clipchamp.Clipchamp_yxz26nhyzhsrt
CloseHandle
CloseServiceHandle
CloseThreadpoolTimer
CLSIDFromString
cmdLine.get() != nullptr
cmdLineBuilder.AppendChar(L' ')
cmdLineBuilder.AppendChar(L'\"')
cmdLineBuilder.AppendString(applicationPath)
cmdLineBuilder.AppendString(offlineSoftwareHive)
cmdLineBuilder.AppendString(offlineSoftwareHiveParam)
cmdLineBuilder.AppendString(packagePath)
cmdLineBuilder.SetLength(0)
CoCreateInstance
CoCreateInstance( __uuidof(AppxBundleFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IAppxBundleFactory), &appxFactory)
CoCreateInstance( __uuidof(OpcFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IOpcFactory), &opcFactory)
CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskService, static_cast<void**>(&taskService))
CoGetApartmentType
CoGetInterfaceAndReleaseStream
CoInitializeEx
com1.
com2.
com3.
com4.
com5.
com6.
com7.
com8.
com9.
CoMarshalInterThreadInterfaceInStream
CoMarshalInterThreadInterfaceInStream(IID_IMigrationContext, this->context, &pStream)
Common::Deployment::Configuration::GetPackageRepositoryRoot(&this->packageRepository)
Common::Deployment::CreateAppInstallerTask()
Common::Deployment::GetPackageIDFromPackageMoniker( existingFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( packageFullName, nullptr, &currentPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( provisionedInstalledPackageFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( uplevelProvisionedPackage, nullptr, &provisionedPackageID)
Common::Deployment::GetVersionlessNameFromPackageFullName( fullName, &versionlessName)
Common::Deployment::GetVersionlessNameFromPackageFullName( packageFullName, &versionlessName)
Common::Deployment::GetVersionlessNameFromPackageFullName(packageFullName, &versionlessName)
Common::Deployment::ManifestCache::UpdateOptions(Common::Deployment::ManifestCache::Options_ReloadAllInbox)
Common::Deployment::SaveWindowsAppsPackageListToFile(filename.GetChars())
Common::DirectoryExists(autogenDirectoryPath.GetChars(), &folderExists)
Common::DirectoryExists(folderPath, &folderExists)
Common::DirectoryExists(metadataFolder.GetChars(), &metadataExistsInPackageRoot)
Common::DirectoryExists(metadataFolderInSharedLimitedTime.GetChars(), &packageExistsInSharedLimitedTime)
Common::DirectoryExists(systemMetadataDirectoryForPackage, &systemMetadataForPackageExists)
Common::FileExists(applyTrustLabelAppFullPath.GetChars(), &fileExists)
Common::FileExists(fileName.GetChars(), &fileExists)
Common::FileExists(recoveryFileFullPath.GetChars(), &recoveryFileExists)
Common::FileExists(sourceBackupManifestFilePathBuilder.GetChars(), &sourceFileExists)
Common::FileExists(targetBackupManifestFilePath.GetChars(), &targetFileExists)
Common::StateSeparation::GetPackageRepositoryPackagesPath(nullptr, &packageRepositoryPackagesKeyPath)
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppModelRoot, &s_StubPreference, 1, &stubPreferenceKeyPath)
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppxStateChange, subkeys, ARRAYSIZE(subkeys), &fullPath)
Common::String::CaseInsensitiveStartsWith(subKey, L"S-", &isUserSid)
CompanyName
CompareStringOrdinal
Completed AppxPreRegisterAllInboxPackages
Completed EnsureAppRootPermissions - processed %i of %i directories.
Completed EnsureRegistryKeyPermissions
Completed EnumAndAddPackagesNotKnownToCapAuth
Completed FixStateRepositoryIntegrity -- was already run so no action needed.
Completed FixStateRepositoryIntegrity successfully.
Completed RepairBadPathsInHKU
Completed RepairPackageRepositoryKeyInHKLM
Completed RepairPackageRootFolderPathInRepositoryRegistryKey
Completed RepairPathValueInUserRegistryKey
Completed RepairStateRepository successfully.
context->ExpandEnvironmentVariables(pathBstr, &expandedPath)
context->get_WorkingDir(&workingDir)
context->GetOfflineFileLocation(expandedPath, &offlinePath)
context->GetOfflineStatus(&offlineExecution)
ConvertInterfaceGuidToLuid
ConvertStringSidToSid(packageContentsCapabilitySid, &packageContentsSid)
ConvertStringSidToSidW
CopyFile(sourceBackupManifestFilePath.GetChars(), targetBackupManifestFilePath.GetChars(), FALSE)
CopyFileW
CopyRegistryKeyWithoutAcls(allUserStoreKey, pluginAllUserStoreKey)
CopyRegistryKeyWithoutAcls(packageStateKey, stateChangeKey)
CopyRegistryKeyWithoutAcls(sourceSubKey, destinationSubKey)
CopyRegistryKeyWithoutAcls(stubPreferenceKey, stubPreferenceKeyCopy)
CoTaskMemAlloc
CoTaskMemFree
Could not open %ls: 0x%x -- not performing EOL and provisioned-package cleanup
CoUninitialize
CreateAppxProvisionFactory(&appxProvisionFactory)
created
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeKeyString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeNameString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeKeyString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeNameString, value.GetChars())
CreateEventW
CreateFileW
CreateMutexExW
CreateProcessW
CreateSemaphoreExW
CreateThread
CreateThreadpoolTimer
CreateTopLevelKeys(offlineExecution)
currentContextId
currentContextMessage
currentContextName
currentPackage->packageFullName.SetValueFromString(packageFullName)
D$ E3
D$(D8eXt
D$(E3
D$,D8-$
D$@E3
D$`D;
D$`D8\$ht
D$`E3
D$`fD98t
D$`H9|$Xu
D$DE;
D$HE3
D$hfE
d$pA!,$I
D$pE3
D$PH!\$(3
D$PH!|$(3
D$PH9\$Hu
D$pI9_
D$xE3
D$XL9d$Pu
D;}(r
D;v(r
D+D$x
D+D$xD
D8|$@u)L
D8|$@uUL
D8|$0
D8|$XA
D8}gt%H
D8=bb
D8d$@t5L
D8d$0t)L
D8d$0u;L
D8d$0u[M
D8d$1
D8d$P
D8M8A
D8mwtnL
D9 u]H
D9|$(|
D9|$D
D9|$Du
D97t<A
D9d$(
D9d$L
D9l$(|
DeleteCriticalSection
Deleted\
DeleteFileW
Deleting Uplevel all-user key %ls because downlevel had a more preferred version
Deprovisioned
DeprovisionedKey does not exist. FixDeprovisionedKey has nothing to do.
deprovisionedKey.DeleteSubKey(packageFamilyName)
deprovisionedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, deprovisionedSD)
deprovisionedKey.KeyExists(packageFamilyName, &isInDeprovisionedKey)
deprovisionKey.CopyTree(nullptr, this->pluginDeprovisionedKey)
deprovisionKey.KeyExists(familyName, packageDeprovisioned)
destination.CreateSubKey(subKeyName, KEY_READ | KEY_WRITE, &destinationSubKey)
destination.SetValue(nameBuffer.GetChars(), valueBuffer.GetBufferPtr(), valueLength, valueType)
Determining if no re-registration of packages is needed failed with 0x%x. We will just default to re-registering all apps.
DeviceIoControl
DEVOBJ.dll
DevObjCreateDeviceInfoList
DevObjDestroyDeviceInfoList
DevObjEnumDeviceInfo
DevObjGetClassDevs
DevObjGetClassDevs(deviceInfoList.get(), &GUID_DEVCLASS_NET, nullptr, DOGCF_PRESENT, nullptr, 0)
DevObjOpenDevRegKey
Did not find cached migration XML, generating new one
Did not find export %ls: 0x%x.
Did not find module %ls: 0x%x
DirectoryPaths::CreateFullFileName(destDirectory, findFileData.cFileName, &destPath)
DirectoryPaths::CreateFullFileName(sourceDirectory, findFileData.cFileName, &srcPath)
DisableThreadLibraryCalls
DiscoverFailed
DllCanUnloadNow
DllGetClassObject
Doesn't match stub preference while %ls does
Downlevel installed package not found for the user %ls and package %ls
Downlevel OS already had package %ls registered for user %ls, writing to UserSid Key
Downlevel OS already had package %ls registered, not writing to Staged Key
downlevelAllUserPackageKey.GetStringValueIfExists(AppxAllUserStore::regValueRegions, &regionsValue, &valueExists)
DownlevelGather
DownlevelInstalled
downlevelInstalledKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
DownlevelOSVersion
DownlevelPackageRepositoryRoot
DownlevelPackageRoot
E(=csm
E;f(r
E8~1u
E8~2u
E8=csm
E9f(v)I
effectivePath.SetValueFromString(expandedPath)
effectivePath.SetValueFromString(offlinePath)
Eh=csm
EH=csm
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
EndOfLife
endOfLifeKey.GetKeySecurity(DACL_SECURITY_INFORMATION, endOfLifeSD)
endOfLifeKey.Open(HKEY_LOCAL_MACHINE, endOfLifePath.GetChars(), KEY_READ)
EnsureACLOnObject(SE_FILE_OBJECT, fullFilePath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_FILE_OBJECT, targetPath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_REGISTRY_KEY, perUserACLPathBuffer.GetChars(), packageContentsSid.get())
EnsureAppRootPermissions(offlineMode)
EnsureAppxDeploymentClientDllLoaded(&deploymentClientModule)
EnsureDelayLoadGetStagedPackagePath()
EnterCriticalSection
EnumAndAddPackagesNotKnownToCapAuth(userSid, packagesToReRegister.Get())
EnumAndAddSubKeysToStringVector(&inboxPackagesKey, packagesToReRegister.Get(), s_PackagesToReRegister)
EnumAndAddSubKeysToStringVector(&userPackagesToRegisterKey, packagesToReRegister.Get(), s_PackagesToReRegister)
EnumerateAndCachePackagesInAllUserStoreUsingGatheredData()
EnumerateUsersAndPopulateUserSids()
Enumerating pre-Win10 packages registered to %ls but not known to CapAuth
EnumKey for [%ls] failed: 0x%x
EnumValue for [%ls] failed: 0x%x
eolPackages->GetCurrent(&package)
error != ERROR_NO_MORE_FILES
Error getting effective rights from ACL for %ls - 0x%x
Error getting SD for %ls - 0x%x
Error retrieving IRepositoryManager 0x%x
Error retrieving IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
Error returned when repairing reg key HKEY_USERS\%ls%ls
ERROR_INSUFFICIENT_BUFFER != this->GetStagedPackagePathByFullName(packageFullName.GetRawBuffer(nullptr), &packageRootLength, nullptr)
Erroring adding to ACL to %ls - 0x%x
Erroring setting new SD for %ls - 0x%x
EtwEventRegister
EtwEventUnregister
EtwEventWrite
EventRegister
EventSetInformation
EventUnregister
EventWriteTransfer
everyoneSid.Initialize(Common::Deployment::EveryoneSid.chars, Common::Deployment::EveryoneSid.length)
EX=csm
Ex=csm
EX9F4tZ
EX9G$tV
EX9G4t6
Exception
Exclude infused apps failed with 0x%x. Ignoring this error.
Exclude leftover invalid registries failed with 0x%x. Ignoring this error.
Exclude leftover manifest files failed with 0x%x. Ignoring this error.
ExcludeFiles
excludeFilesKey.CreateSubKey(fileName.GetChars(), KEY_READ | KEY_WRITE, &fileKey)
excludeFilesKey.OpenSubKey(file, KEY_READ, &fileKey)
ExcludeInfusedApps
excludeInfusedAppsKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
excludeInfusedAppsKey.OpenSubKey(package, KEY_READ, &packageKey)
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved, existingPreferredPackage->isPaused)
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved, existingPackageIsPaused)
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved, packageIsPaused)
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved, packageIsPaused)
ExcludePackagesWithinKeyUsingGatheredData(&stagedKey, &allUserStoreStagedPath)
ExcludePackagesWithinKeyUsingGatheredData(&userSidKey, &fullPathToUserSidKey)
Excluding InfusedApps folder %ls
exists
Expanded Path value: %ls, value length: %u
Expanded SIS path: %ls
ExpandEnvironmentStrings(appRepositoryPath, appRepositoryExpandedPath, ARRAYSIZE(appRepositoryExpandedPath)) == 0
ExpandEnvironmentStrings(appRepositoryPath, expandedPath, ARRAYSIZE(expandedPath)) == 0
ExpandEnvironmentStringsW
ext-ms-onecore-appmodel-staterepository-internal-l1-1-2.dll
ext-ms-onecore-appmodel-staterepository-internal-l1-1-6.dll
ext-ms-win-security-capauthz-l1-1-1.dll
f9,Au
f9,Cu
f9,Ou
f9<Au
f9<Bu
f94Cu
f94Ku
fA9,@u
fA9,Pu
fA9<@u
fA9>u
fA9T>
Failed looking for a cellular modem
Failed processing bundle %ls with 0x%x. Ignoring failure to continue with processing
Failed processing framework package %ls with 0x%x. Ignoring failure to continue with processing
Failed Processing inbox or devmode package for user with 0x%x. Ignoring failure to continue with processing
Failed processing main package %ls with 0x%x. Ignoring failure to continue with processing
Failed processing optional package %ls with 0x%x. Ignoring failure to continue with processing
Failed Processing package for user with 0x%x. Ignoring failure to continue with processing
Failed processing resource package %ls with 0x%x. Ignoring failure to continue with processing
Failed querying CapAuth for user=%ls package=%ls: 0x%X
Failed to ApplyTrustLabel - CreateProcess Failed - 0x%x - %ls
Failed to ApplyTrustLabel - GetExitCodeProcess Failed - 0x%x - %ls
Failed to ApplyTrustLabel - InitializeProcThreadAttributeList Failed - 0x%x - %ls
Failed to ApplyTrustLabel - UpdateProcThreadAttribute Failed - 0x%x - %ls
Failed to ApplyTrustLabel offline to Plugin Staged Packages - 0X%x
Failed to ApplyTrustLabel offline to Plugin Staged User Acquired Packages - 0X%x
Failed to ApplyTrustLabel offline to PreInstalled Packages - 0X%x
Failed to create per-machine keys 0x%x
Failed to create reg key %ls with 0x%x
Failed to enumerate all users with 0x%x
Failed to enumerate downlevel installed packages for the user %ls with 0x%x, will re-install all apps
Failed to enumerate packages for the user %ls with 0x%x
Failed to exclude file %ls in XML Writer: 0x%x
Failed to exclude registry %ls in XML Writer: 0x%x
Failed to get junction target for : %ls - 0x%x
Failed to get Registry key value [%ls]
Failed to get WorkingDir 0x%x
Failed to include directory %ls in XML Writer: 0x%x
Failed to include directory %ls, file %ls in XML Writer: 0x%x
Failed to include registry %ls in XML Writer: 0x%x
Failed to include registry key %ls, value %ls in XML Writer: 0x%x
Failed to merge registry %ls in XML Writer: 0x%x
Failed to merge registry key %ls, value %ls in XML Writer: 0x%x
Failed to move directory %ls to backup folder in XML Writer: 0x%x
Failed to open reg key %ls with 0x%x
Failed to open reg key HKEY_USERS\%ls%ls, offlineMode: %ls
Failed to open sub-key %ls of root key %ls, hr: 0x%x
Failed to PerformApplySuccessOnlinePerMachineTasks with 0x%x
Failed to process all installed packages with 0x%x
Failed to process all user store packages with 0x%x
Failed to process AppxProvisioning XML for end of life packages 0x%x. Proceeding as if AppxProvisioning XML does not exist so user acquired apps get processed
Failed to process bundle manifest packages: 0x%x. Excluding Bundle.
Failed to processing all packages during AppxUpgradeMigration ApplySuccess with 0x%x
Failed to repair reg value [%ls] for package %ls, hr: 0x%x
Failed to repair reg value [%ls] for reg key %ls, hr: 0x%x
Failed to set the FlushInboxCachedManifests in the AppxAllUserStore with 0x%x
Failed to update registry ACLs for '%ls': 0x%x.
Failed to write oem uninstalled packages for user %ls with 0x%x
Failed to write out migration XML with 0x%x
Failed to write packages to re-register for user %ls with 0x%x
Failed to write provisioned packages to staged list with 0x%x
Failed with 0x%08lx reading %ls value PackageStatus, assuming package has no in-place update pending
Failed with 0x%x to set %ls key value
FailFast
failureCount
failureId
failureType
FallbackError
false
FamilyName
familyName->GetLength() == familyNameLength
familyName->SetLength(familyNameLength)
familyName->SetValue(fullName, nameLength)
familyNameBuffer.SetValueFromString(familyName.GetChars())
familyNameBuffer.SetValueFromString(packageFamilyName)
familyNameBuilder.AppendString(cursor)
fB9<[u
fD9 t
fD9!H
fD9$Au
fD9$Ou
fD9$qu
fD9(t
fD9,Vu
fD9/A
fD9?w
fD9}ot>D8}g
fD9+tSH
fD9+tt
fD9+u
fD9<Au
fD94Hu
fD98t
fD9DO
fD9e8A
fD9t}
fD9u 
fD9u0
fD9u0u
fD9u8
fE9 H
fE9,Au
fF9$Au
fF9,wu
ffD9u0
fg:SM
File %ls in working dir: %ls
File: %ls
FileDescription
fileKey.GetStringValue(s_Path, &filePath)
fileKey.SetStringValue(s_Path, fullFilePath.GetChars())
fileName
fileName.SetLength(fileName.GetLength() - wcslen(L".xml"))
fileName.SetValueFromString(findFileData.cFileName)
fileNameBuilder.AppendChar('\\')
fileNameBuilder.AppendString(expandedPath)
filenameBuilder.AppendString(OSRollbackPackagesFilename)
fileNameBuilder.AppendString(stateRepositoryMachineDatabase)
fileNameBuilder.AppendString(stateRepositoryWalFile)
filenameBuilder.AppendString(workingDir)
FileVersion
FindClose
FindFirstFileW
findMethod(packageInfoCollection.GetAddressOf())
FindNextFileW
Finished AppxUpgradeMigration ApplySuccess for %ls with 0x%x
Finished AppxUpgradeMigration ApplySuccess offline with 0x%x
FixDeprovisionedKey(pluginAllUserStoreKey)
FixDeprovisionedKey: Deprovisioned key has %ls, while Applications key has %ls. Deleting package from Deprovisioned key.
Fixing
FixStateRepositoryIfPossible called
FixStateRepositoryIfPossible completed Disposition=%d
FixStateRepositoryIfPossible failed (0x%x) Disposition=%d
FixStateRepositoryIfPossible(disposition)
FixStateRepositoryIntegrity(repositoryManager)
FixStateRepositoryIntegrityCompleted
FixStateRepositoryOrResetMaintenance already executed
FixStateRepositoryOrResetMaintenance called
FixStateRepositoryOrResetMaintenance done
FixStateRepositoryOrResetMaintenance()
FixStateRepositoryViaExport(disposition)
FixStateRepositoryViaRepositoryManager called
FixStateRepositoryViaRepositoryManager done. Disposition %d
FixStateRepositoryViaRepositoryManager(disposition)
flipgrid.com-8F71AE01_mthbhdxggzve2
FlushInboxCachedManifests
folderPathBuilder.AppendString(backupFolderNameWithSlash)
folderPathBuilder.AppendString(fullName)
folderPathBuilder.AppendString(L"\\")
folderPathBuilder.AppendString(systemMetadataFolder)
folderPathBuilder.AppendString(this->singleInstanceStore.GetChars())
Fonecore\admin\appmodel\appxupgrademigrationplugin\src\AppxUpgradeMigrationPluginClass.h
FormatMessageW
Found bad path in reg key value [%ls] that needs repair: %ls
Found cached migration XML
Found Ghosts Entries: %d. Repaired Ghost Entries: %d.
Found IRepositoryManager
Found IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
Framework
framework
Framework package is paused so its package root and backup manifest will be excluded
frameworkPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
frameworksPathBuilder.AppendString(Common::Deployment::frameworksDir)
frameworksPathBuilder.AppendString(infusedAppsFolder.GetChars())
FreeLibrary
fullFilePath->SetValue( moduleFullPath, static_cast<ULONG>(lastBackslash + 1 - moduleFullPath))
fullFilePathBuilder.AppendString(expandedSystem32Path)
fullFilePathBuilder.AppendString(findFileData.cFileName)
fullFilePathBuilder.AppendString(L"\\")
fullFilePathBuilder.AppendString(packagePath)
fullFilePathBuilder.AppendString(path)
fullFilePathBuilder.AppendString(this->packageRepository.GetString())
fullFilePathBuilder.AppendString(this->singleInstanceStore.GetChars())
FullName
fullName.Initialize(packageFullName)
fullNameAsString.Initialize(packageFullName)
fullNameBuffer.SetValueFromString(fullNameToWrite)
fullNameBuffer->SetValueFromString(fullName)
function
Gather.FixStateRepositoryOrResetMaintenance.Failed
GatherDataForExcludeAllInfusedApps()
GatherDataForExcludeAllInfusedAppsInFolder(applicationsFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(frameworksFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(packagesFolder.GetChars())
GatherDataForExcludeLeftoverManifestFiles()
GatherDataForProcessAllBundleResourceAndOptionalPackages()
GatherDataForProcessAllInstalledPackages()
GatherDataForProcessAllMainAndFrameworkPackages()
GatherDataForProcessAllUserStorePackages()
GatherDataForProcessBundleManifestPackages(packageFullName)
GatherDataForProcessPackagesForUser(this->userSids.At(i)->GetChars())
GatherDataForWriteOutPerMachineMigrationXml()
GatherDownlevelData()
GatherFailed
Gathering bundle manifest data for %ls
Gathering data for bundle %ls
Gathering data for main or framework package %ls
Gathering data for optional package %ls
Gathering data for resource package %ls
Gathering data for user package %ls
Gathering install state for package %ls
Gathering packages installed for user %ls
GatherInstallStateForAllPackages()
GatherInstallStateForPackage(packageManager.Get(), package, packageFullName, installStateRootKey)
GatherPackageDataForUser(packageManager.Get(), package, packageFullName, userSid, packageKey)
GatherSingleInstanceStoreDirectories()
GenerateSystemMigrationXml(xmlStream)
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetEffectiveRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), offlineMode, effectiveAllUserStorePathBuffer, effectiveAllUserStorePath)
GetEffectiveRegistryPath(RegistryHive::HKLM, packageRepositoryPackagesKeyPath, offlineMode, effectivePackageRepositoryPackagesKeyPathBuffer, effectivePackageRepositoryPackagesKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginKeyPathBuffer, effectivePluginKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginPathBuffer, effectivePluginPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineMode, effectivePluginPathBuffer, effectivePluginPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, stubPreferenceKeyPath, offlineExecution, effectiveStubPreferenceKeyPathBuffer, effectiveStubPreferenceKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKU, perUserRegistryPathBuffer.GetChars(), offlineMode, effectivePerUserRegistryPathBuffer, effectivePerUserRegistryPath)
GetEffectiveRegistryPath(RegistryHive::HKU, userPath.GetChars(), offlineMode, effectiveUserPathBuffer, effectiveUserPath)
GetEffectiveRightsFromAclW
GetExitCodeProcess
GetFamilyNameFromFullName(fullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &packageFamilyName)
GetFamilyNameFromFullName(subKey, &packageFamilyName)
GetFamilyNameFromFullName(WindowsGetStringRawBuffer(packageFullName, nullptr), &packageFamilyName)
GetFileAttributesW
GetFileVersionInfoEx(FILE_VER_GET_LOCALISED | FILE_VER_GET_NEUTRAL, appxUpgradeMigrationPluginFileName, 0, versionSize, versionData)
GetFileVersionInfoExW
GetFileVersionInfoSizeExW
GetIfEntry2
GetInboxOrDevModePackageManifestPath(packageRootPath, manifestPath)
GetInstalledBundleForUser(packageFamilyName, userSid, &bundleName)
GetIsInboxPackageUsingGatheredData(packageFullName, &isInboxPackage)
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(familyName.GetChars(), false , &packageDeprovisioned)
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(packageFamilyName, false , &packageDeprovisioned)
GetIsStubPreferredForPackageFamilyUsingGatheredData(familyName.GetChars(), &preferStubForFamily)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName, &preferStub)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName.GetChars(), &downlevelPreference)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName->GetChars(), &preferStubForFamily)
GetLastError
GetMetadataFolderForPackage(fullName, false , &metadataFolder)
GetMetadataFolderForPackage(fullName, true , &metadataFolderInSharedLimitedTime)
GetModuleFileName failed 0x%x -- unable to create full file path for %ls
GetModuleFileNameW
GetModuleHandleW
GetNamedSecurityInfoW
GetOfflineFilePath(packagePath.GetChars(), &offlinePackagePath)
GetOfflineFilePath(this->singleInstanceStore.GetChars(), &offlineSystemSisPath)
GetOfflineRegistryPath(hive, path, &resultBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePath.GetChars(), &offlineAllUserStorePath)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), &offlineAllUserStorePathBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, c_messagingKeyPath, &offlineAppxRegKeyPath)
GetOfflineRegistryPath(RegistryHive::HKLM, Common::Deployment::AppXRegKeyPath.chars, &offlineAppxRegKeyPath)
GetOfflineRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, &regPath)
GetOfflineRegistryPath(RegistryHive::HKLM, softwareHive, &offlineSoftwareHive)
GetPackageDirectoryExistsUsingGatheredData(fullName, &exists)
GetPackageDirectoryExistsUsingGatheredData(packageFullName, &exists)
GetPackageInstalledPath(package, packageRootPath)
GetPackageInstallState(packageManager, fullName, nullptr , &packageInstallState)
GetPackageInstallState(packageManager, fullNameAsString, userSid, &packageInstallState)
GetPackageIsPausedUsingGatheredData(packageFullName, &packageIsPaused)
GetPackageIsPausedUsingGatheredData(provisionedInstalledPackageFullName, &provisionedInstalledPackageIsPaused)
GetPackageIsStubUsingGatheredData(packageFullName, &packageIsStub)
GetPackageIsStubUsingGatheredData(provisionedInstalledPackageFullName, &provisionedInstalledPackageIsStub)
GetPersistedRegistryLocationW
GetPluginHasExecutedOffline(executedOffline)
GetPluginHasExecutedOffline: %d for context %ls
GetPluginHasExecutedOfflineValueName(valueName)
GetPluginRelativeFullPath(L"", &manifestPathBuffer)
GetProcAddress
GetProcessHeap
GetServiceStatus(serviceName, &status)
GetStagedPackagePathByFullName
GetStubPreferenceFromKey(stubPreferenceKey, familyName.GetChars(), &packageIsStub)
GetStubPreferenceFromKey(stubPreferenceKey, packageFamilyName, &uplevelProvisionedPackageIsStub)
GetStubPreferenceFromKey(stubPreferenceKey, packageFamilyName->GetChars(), &packageIsStub)
GetStubPreferenceFromKey(stubPreferenceRootKey, packageFamilyName, stubPreferred)
GetStubPreferenceFromKey(uplevelStubPreferenceKey, packageFamilyName.GetChars(), &uplevelPreference)
GetStubPreferenceKey(KEY_READ | KEY_WRITE, uplevelStubPreferenceKey)
GetStubPreferenceKey(KEY_READ, stubPreferenceKey)
GetSystem32FullPath(applyTrustLabelApplication, &applyTrustLabelAppFullPath)
GetSystemSisManifestPathFromPackageFullName( bundleFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName( packageFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName(packageToWrite, &packageManifestPath)
GetSystemTimeAsFileTime
GetSystemWindowsDirectory(systemWindowsDirectory, ARRAYSIZE(systemWindowsDirectory)) == 0
GetSystemWindowsDirectoryW
GetTickCount
GetTickCount64
Getting single instance store path failed with %x, switching to use legacy location
Getting stub preference key with offlineExecution: %d
Getting stub preference key. stubPreferenceKeyPath:  %ls
GetVersionInfo(&osVersion)
h UAVAWH
H!\$ H
H!\$0H!\$(H!\$ 3
H!\$83
H!\$8H!\$0H!\$(H!\$ 3
H!\$8H!\$0H!\$(H!\$ L
H!\$8L
H!|$ H
H!|$(H!|$ H
H!|$0A
H!|$8D
H!|$8L
H!|$x
H!E`M
H!EwH
H!MX3
H!t$x
H_^[]
H9{ tCH
H9}@tX3
H9Q tCH
HA_A^A]A\_^[]
Has same main package as %ls
HasCellularModem
HasModem
HcD$ H
HcQ<H
HeapAlloc
HeapFree
HKCU\
HKLM\
hrActivateInstance
hrAllUserStoreKeySetKeySecurity
hrAppendFullName
hrApplyTrustLabelToPackages
hrApplyTrustLabelToPluginStagedPackages
hrApplyTrustLabelToPluginStagedUserAcquiredPackages
hrApplyTrustLabelToPreInstalledPackages
hrAppxPreRegisterPackage
hrCleanupOrphanPackages
hrCleanupSystemAppsMigratedToFOD
hrCopyBackupManifestForEndOfLifePackagesIfNecessary
hrCopyMetadataIfRequired = CopyMetadataIfRequired()
hrCreateKey
hrCreatePerMachineKeys
hrCreateProvisionStreamingReaderFromFile
hrDeleteOSRollbackPackagesRegistry
hrDeprovisionedKeySetKeySecurity
hrEndOfLifeKeySetKeySecurity
hrEnsureAutogenDeleted
hrEnsureRegistryKeyPermissions
hrEnumBundles
hrEnumerate
hrEnumerateUsersAndPopulateUserSids
hrEnumFamilies
hrEnumFrameworks
hrEnumMainPackages
hrEnumOptionalPackages
hrEnumPackages
hrEnumResourcePackages
hrEnumSubfolders
hrEnumSubkeys
HResult
hresult
HResult
hresult
HRESULT_FROM_WIN32(enumResult)
HRESULT_FROM_WIN32(GetLastError())
hrExcludeAllInfusedApps
hrExcludeFile
hrExcludeKey
hrExcludeLeftoverInvalidRegistries
hrExcludeLeftoverManifestFiles
hrGatherData
hrGetPackageIDFromPackageMoniker
hrGetProvisionXmlPath
hrGetTarget
hrGetValue
hrGetWorkingDir
hrIncludePath
hrIncludeRegistryKey
hrIncludeRegistryValue
hrInitializeUpgradeData
hrIterateBundles
hrIterateOptionalPackages
hrIteratePackages
hrIterateResourcePackages
hrMarkUplevelProvisionedPausedPackagesAsStaged = MarkUplevelProvisionedPausedPackagesAsStaged()
hrMergeRegistryKey
hrMergeRegistryValue
hrMovePathToBackupFolder
hrOpenKey
hrOpenPackagesToRemove
hrPluginAppxKeyOpen
hrPluginAppxKeyOpenAppxAllUserStore
hrPluginAppxKeyOpenSubKeyApplications
hrPluginOpenPackagesToCheckForStagingCompletion
hrPluginOpenPackagesToReRegister
hrPopulateAppxProvisionXmlLists
hrPreRegister
hrPreRegisterAllPackages
hrProcessAllInstalledPackages
hrProcessAllUserStorePackages
hrProcessBundleManifestPackages
hrProcessInboxOrDevModePackageForUser
hrProcessPackage
hrProcessPackageForUser
hrProcessRecoveryData
hrProcessSingletonPackages
hrReadAppXMigrationStores
hrReIndexPackagesForFeatureLightUp = ReIndexPackagesForFeatureLightUp()
hrRemoveUplevelProvisionedUnneededPackages = RemoveUplevelProvisionedUnneededPackages()
hrRepairBadPathsInHKU
hrRepairPackageRepository
hrRepairPackageRootFolderPath
hrRepairStateRepository
hrSavePackageListFromFileToRegistry
hrSetupPackagesForReRegistration
hrSetValue
hrStagedKeySetKeySecurity
hrUserPackagesToReRegisterKey
hrWrite
hrWriteAllUserStoreKeys
hrWriteFrameworkMap
hrWriteOutPerMachineMigrationXml
hrWriteOutPerUserMigrationXml
hrWritePackagesToReRegisterKeys
hrWriteResourceMap
hrWriteUninstalledKeys
http://schemas.microsoft.com/appx/2013/appxprovisionpackage
I;v@r
I0G1-0+
If the OS doesn't support packageManager2 interface then no resource and bundles can be installed--no bundles and resources to process. 
Ignoring error: Package %ls failed to ensure deleted Autogen: 0x%x
Ignoring error: Package %ls failed to preregister: 0x%x
Ignoring package %ls with unknown property type %x
ImportPackageUserStatusToStateRepository imported status from %d packages and failed to import status from %d packages
ImportPackageUserStatusToStateRepository(userSidString)
InboxApplications
inboxPackagesKey.Open(HKEY_LOCAL_MACHINE, inboxPackagesBuffer.GetChars(), KEY_READ)
infusedPathBuilder.AppendString(Common::Deployment::infusedAppsDir)
infusedPathBuilder.AppendString(systemWindowsDirectory)
InitializeCmdLine(applicationPath, offlineSoftwareHive, cmdLineBuilder)
InitializeCriticalSection
InitializeCriticalSectionEx
InitializePackageRepositoryRoot()
InitializePluginRegistryKeys(offlineExecution, &appxKeyFound)
InitializeProcThreadAttributeList
InitializeSRWLock
InitializeSystemSisFullPath()
InitOnceBeginInitialize
InitOnceComplete
Inserting %ls since it was brought by a bundle %ls
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , false , &comparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , true , &comparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , true , &packagePreferenceComparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &versionlessName, &this->frameworkMap, false , false )
InsertToPreferredMapUsingGatheredData(fullName, &familyNameBuffer, &this->combinedProvisionedMap, true , false , &comparison)
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, &this->frameworkMap, true , false )
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, &this->resourceMap, true , false )
InsertToPreferredMapUsingGatheredData(packageFullName, &versionlessName, &this->resourceMap, false , true )
InSingleInstanceStore
installedLocation.As(&installedLocationStorageItem)
installedLocationStorageItem->get_Path(packagePath.ReleaseAndGetAddressOf())
InstalledPackages
installedPackagesKey.CreateSubKey(s_Bundle, KEY_READ | KEY_WRITE, &bundlesKey)
installedPackagesKey.CreateSubKey(s_Framework, KEY_READ | KEY_WRITE, &frameworkPackagesKey)
installedPackagesKey.CreateSubKey(s_Main, KEY_READ | KEY_WRITE, &mainPackagesKey)
installedPackagesKey.CreateSubKey(s_Optional, KEY_READ | KEY_WRITE, &optionalPackagesKey)
installedPackagesKey.CreateSubKey(s_Resource, KEY_READ | KEY_WRITE, &resourcePackagesKey)
installedPackagesKey.OpenSubKey(s_Bundle, KEY_READ, &bundlesKey)
installedPackagesKey.OpenSubKey(s_Framework, KEY_READ, &frameworkPackagesKey)
installedPackagesKey.OpenSubKey(s_Main, KEY_READ, &mainPackagesKey)
installedPackagesKey.OpenSubKey(s_Optional, KEY_READ, &optionalPackagesKey)
installedPackagesKey.OpenSubKey(s_Resource, KEY_READ, &resourcePackagesKey)
InstallState
installStateKey.OpenSubKeyIfExists(provisionedPackageFullName, KEY_READ, &packageKey)
installStateRootKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
installStateRootKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &packageKey)
InternalName
INVALID_HANDLE_VALUE == deviceInfoList.get()
IPHLPAPI.DLL
Is a framework package
Is a LOB app
Is a main or bundle package
Is a resource package
Is a top level package
Is being DROPPED because it is a de-provisioned package
Is higher version than %ls
Is less preferred than %ls
Is lower version than %ls
Is more preferred than %ls
Is same version as %ls
IsDebuggerPresent
IsDevModeApp
IsFixStateRepositoryAlreadyExecuted(alreadyExecuted)
IsFramework
IsLOBApp
IsPackageInEndOfLifeKey(endOfLifeMissingManifestFixablePackageFullNames[i], &isInEndOfLifeKey)
IsPackageRegistrationPreservedAcrossUpgrade()
IsPluginDeprovisionedPackage(&allUserStoreKey, packageFamilyName, &isDeprovisioned)
IsStub
IUIPolicyChecked
J>f;O
Keep thread running start.
KERNEL32.dll
kernelbase.dll
key.Open(HKEY_LOCAL_MACHINE, effectiveStubPreferenceKeyPath, access)
key.OpenSubKeyIfExists(packageFamilyName, KEY_READ, &packageFamilyKey)
key.ValueExists(valueName.GetChars(), &hasExecutedOffline)
key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)
key->OpenSubKey(userSid, KEY_READ, &userSidKey)
keysToDelete.Add(uplevelPackageToDelete)
L!l$8L!l$0L!l$(L!l$ L
l$ E3
L$ SUVWH
L$ SVWAVH
L$ SVWH
L$ UVWATAUAVAWH
l$ VWAVH
L$ VWAVH
L$(E3
L$@fD
L$@H!\$0L
L$@H3
L$@I+
L$@L+
L$`9L$Pu
L$`E3
L$`H3
L$0fD
L$0H3
L$8E3
L$DH!|$0L
L$HD8
L$hH+
L$hH3
l$pE3
L$PH;
L$XfD
L9{Hu
L9|$Hu
L9|$xu
L9d$`u
L9d$Hu
L9t$8u
L9t$Hu
L9t$xu
L9u@L
L9u@uw
LastReturnValue
LcA<E3
LeaveCriticalSection
LegalCopyright
lineNumber
lntdll.dll
Loading ext-ms-win-security-capauthz-l1-1-1.dll
LoadLibraryExW
LoadLibraryW
LoadUpgradeDataFromPluginKey()
Local\SM0:%lu:%lu:%hs
LocalFree
LocationModifyStringForInfusedApps
LocationModifyStringForWindowsApps
LOG_IF_FAILED(%hs) failed with 0x%x
LOG_IF_FAILED_MSG(%hs) failed with 0x%x. Message is below:
LogHr
LogNt
lpt1.
lpt2.
lpt3.
lpt4.
lpt5.
lpt6.
lpt7.
lpt8.
lpt9.
m:AppxProvisionList
m:AppxProvisionList/m:EndOfLife/m:Package/@FamilyName
m:AppxProvisionList/m:Provisioned/m:Package/@FullName
m:EndOfLife
m:EndOfLife/m:Package
m:Package
m:Provisioned
m:Provisioned/m:Package
m<&8cx
M0K0I
MACHINE
Main package
mainPackageKey.GetStringValueIfExists(AppxAllUserStore::regValueRegions, &regionsValue, &valueExists)
mainPackageKey.GetUInt32ValueIfExists(AppxAllUserStore::regValueIsLOBApp, &isLOBApp, &valueExists)
mainPackageKey.SetStringValue( AppxAllUserStore::regValuePath, packageManifestPath.GetStringRef())
mainPackageKey.SetStringValue(AppxAllUserStore::regValueRegions, AppxAllUserStore::allRegionsString)
mainPackageKey.SetStringValue(AppxAllUserStore::regValueRegions, regionsValue.GetChars())
mainPackageKey.SetUInt32Value(AppxAllUserStore::regValueIsLOBApp, 1)
mainPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
MaintenanceLastPerformed
malloc
ManifestCacheOptions
manifestPackageID->GetPackageFullName(&packageFullName)
manifestPath.SetValueFromString(packageRoot.GetRawBuffer(nullptr))
manifestPathBuilder.AppendChar(L'\\')
manifestPathBuilder.AppendString(&Common::Deployment::BundleManifestFileName)
manifestPathBuilder.AppendString(&Common::Deployment::ExtendedPathPrefix)
manifestPathBuilder.AppendString(&Common::Deployment::ManifestFileName)
manifestPathBuilder.AppendString(packageFullName)
manifestPathBuilder.AppendString(this->singleInstanceStore.GetChars())
Matches stub preference while %ls doesn't
memcmp
memcpy
memcpy_s
memmove
memmove_s
memset
message
messagingKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_READ)
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_WRITE)
metadataPathBuilder.AppendString(fullName)
metadataPathBuilder.AppendString(sisPath)
metadataPathBuilder.AppendString(systemMetadataFolder)
MHH!}@H
Microsoft
Microsoft America Operations1&0$
Microsoft Corporation
Microsoft Corporation1
Microsoft Corporation1%0#
Microsoft Corporation1&0$
Microsoft Corporation1.0,
Microsoft Corporation1200
Microsoft Time-Stamp PCA 2010
Microsoft Time-Stamp PCA 20100
Microsoft Time-Stamp Service
Microsoft Time-Stamp Service0
Microsoft Windows0
Microsoft.549981C3F5F10_8wekyb3d8bbwe
Microsoft.BingNews_8wekyb3d8bbwe
Microsoft.BingWeather_8wekyb3d8bbwe
Microsoft.CommsPhone_8wekyb3d8bbwe
Microsoft.D3DMappingLayers_8wekyb3d8bbwe
Microsoft.DesktopAppInstaller_8wekyb3d8bbwe
Microsoft.GamingApp_8wekyb3d8bbwe
Microsoft.GetHelp_8wekyb3d8bbwe
Microsoft.Getstarted_8wekyb3d8bbwe
Microsoft.HEIFImageExtension_8wekyb3d8bbwe
Microsoft.Messaging_8wekyb3d8bbwe
Microsoft.MicrosoftOfficeHub_8wekyb3d8bbwe
Microsoft.MicrosoftPowerBIForWindows_8wekyb3d8bbwe
Microsoft.MicrosoftSkyDrive_8wekyb3d8bbwe
Microsoft.MicrosoftSolitaireCollection_8wekyb3d8bbwe
Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe
Microsoft.MicrosoftTeamsforSurfaceHub_8wekyb3d8bbwe
Microsoft.MinecraftEducationEdition_8wekyb3d8bbwe
Microsoft.MixedReality.Portal_8wekyb3d8bbwe
Microsoft.Office.Desktop.Access_8wekyb3d8bbwe
Microsoft.Office.Desktop.Excel_8wekyb3d8bbwe
Microsoft.Office.Desktop.OneNote_8wekyb3d8bbwe
Microsoft.Office.Desktop.Outlook_8wekyb3d8bbwe
Microsoft.Office.Desktop.PowerPoint_8wekyb3d8bbwe
Microsoft.Office.Desktop.Project_8wekyb3d8bbwe
Microsoft.Office.Desktop.Publisher_8wekyb3d8bbwe
Microsoft.Office.Desktop.SkypeForBusiness_8wekyb3d8bbwe
Microsoft.Office.Desktop.Visio_8wekyb3d8bbwe
Microsoft.Office.Desktop.Word_8wekyb3d8bbwe
Microsoft.Office.Desktop_8wekyb3d8bbwe
Microsoft.Office.Excel_8wekyb3d8bbwe
Microsoft.Office.PowerPoint_8wekyb3d8bbwe
Microsoft.Office.Word_8wekyb3d8bbwe
Microsoft.OneConnect_8wekyb3d8bbwe
Microsoft.Paint_8wekyb3d8bbwe
Microsoft.People_8wekyb3d8bbwe
Microsoft.PowerAutomateDesktop_8wekyb3d8bbwe
Microsoft.ScreenSketch_8wekyb3d8bbwe
Microsoft.SecHealthUI_8wekyb3d8bbwe
Microsoft.SkypeApp_kzf8qxf38zg5c
Microsoft.StorePurchaseApp_8wekyb3d8bbwe
Microsoft.Todos_8wekyb3d8bbwe
Microsoft.UI.Xaml.2.4_8wekyb3d8bbwe
Microsoft.UI.Xaml.2.7_8wekyb3d8bbwe
Microsoft.VCLibs.140.00_8wekyb3d8bbwe
Microsoft.VP9VideoExtensions_8wekyb3d8bbwe
Microsoft.WebMediaExtensions_8wekyb3d8bbwe
Microsoft.WebpImageExtension_8wekyb3d8bbwe
Microsoft.Whiteboard_8wekyb3d8bbwe
Microsoft.Windows.AppxMigrationPlugin
Microsoft.Windows.Photos_8wekyb3d8bbwe
Microsoft.Windows.SecondaryTileExperience_10.0.0.0_neutral__cw5n1h2txyewy
Microsoft.WindowsAlarms_8wekyb3d8bbwe
Microsoft.WindowsCalculator_8wekyb3d8bbwe
Microsoft.WindowsCamera_8wekyb3d8bbwe
Microsoft.WindowsCommunicationsApps_8wekyb3d8bbwe
Microsoft.WindowsFeedbackHub_8wekyb3d8bbwe
Microsoft.WindowsMaps_8wekyb3d8bbwe
Microsoft.WindowsNotepad_8wekyb3d8bbwe
Microsoft.WindowsSoundRecorder_8wekyb3d8bbwe
Microsoft.WindowsStore_8wekyb3d8bbwe
Microsoft.WindowsTerminal_8wekyb3d8bbwe
Microsoft.Xbox.TCUI_8wekyb3d8bbwe
Microsoft.XboxGameOverlay_8wekyb3d8bbwe
Microsoft.XboxGamingOverlay_8wekyb3d8bbwe
Microsoft.XboxIdentityProvider_8wekyb3d8bbwe
Microsoft.XboxSpeechToTextOverlay_8wekyb3d8bbwe
Microsoft.YourPhone_8wekyb3d8bbwe
Microsoft.ZuneMusic_8wekyb3d8bbwe
Microsoft.ZuneVideo_8wekyb3d8bbwe
Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\
MicrosoftWindows.Client.WebExperience_cw5n1h2txyewy
MigrateDownlevelStubPreference()
MigXml
MigXmlWriter::Create(false , nullptr, &xmlWriter)
MigXmlWriter::Create(true , &this->pluginDownlevelGatherKey, &xmlWriter)
MigXmlWriter::GatherDataForEnvironmentStrings(this->pluginDownlevelGatherKey)
module
Msg:[%ws] 
msvcrt.dll
N0L0J
nameBuffer.SetCapacity(nameBufferLength)
NetCfgInstanceId
neutral
NewParser
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
No %ls found - cannot apply trust labels
No Applications Plugin key found--downlevel had no OEM apps or newer all-user apps to copy over
No need to write Applications Key because uplevel provisioned package %ls is the most preferred version
No PackagesToCheckForStagingCompletion Plugin key found
No PackagesToRemove Plugin key found
No PackagesToReRegister Plugin key found
No Plugin Applications key found. Downlevel had no OEM apps or newer all-user apps to copy over
No Plugin key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin key found--downlevel had no apps or Discover/Gather failed.
No Plugin Staged key found. As far as we know, user had no packages to ApplyTrustLabel
No Plugin Staged key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin StagedUserAcquired key found. As far as we know, User had no packages
No Plugin StagedUserAcquired key found. As far as we know, user had no packages to ApplyTrustLabel
No work to do for DEFAULT user. Skipping.
NoReRegisterOnUpgrade
not found
Not generating migration XML on downlevel system since new packages can still be provisioned on uplevel image.  Migration XML will be generated during Discover on uplevel system.
Not Removing up-level provisioned deprovisioned Package because a user has it still installed: %ls
NtClose
NtCreateSection
ntdll.dll
NtMapViewOfSection
NtQueryWnfStateData
NtUnmapViewOfSection
NtUpdateWnfStateData
o(;o(v
O0M0K
offlineFilePath->SetValueFromString(reinterpret_cast<PCWSTR>(bstrOfflineFilePath.Value()))
offlinePathBuilder.AppendChar(L'\"')
offlinePathBuilder.InsertChars(0, L" \"", 2)
offlineRegistryPath->SetValueFromString((reinterpret_cast<PCWSTR>(bstrOfflineRegistryPath.Value())) + hivePrefixLength)
OLEAUT32.dll
onecore\admin\appmodel\appxupgrademigrationplugin\src\appxupgrademigrationpluginclass.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\migxmlwriter.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\recoveryreader.cpp
onecore\admin\appmodel\common\alluserstorepaths.cpp
onecore\admin\appmodel\common\configuration.cpp
onecore\admin\appmodel\common\directorypaths.cpp
onecore\admin\appmodel\common\downlevelhelper.cpp
onecore\admin\appmodel\Common\ManifestCache.hpp
onecore\admin\appmodel\common\mountedfolder.cpp
onecore\admin\appmodel\common\packagefullnameutilities.cpp
onecore\admin\appmodel\common\PackageID.inl
onecore\admin\appmodel\common\scheduledtaskhelper.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackage.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackageenumerator.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionreader.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionwriter.cpp
onecore\base\appmodel\appxprovisionpackage\src\commonhelpers.cpp
onecore\base\appmodel\common\autocotaskmemstring.cpp
onecore\base\appmodel\common\bytebuffer.cpp
onecore\base\appmodel\common\pathhelpers.cpp
onecore\base\appmodel\common\registrykey.cpp
onecore\base\appmodel\common\stateseparation.cpp
onecore\base\appmodel\common\stringbuilder.cpp
onecore\base\appmodel\common\stringset.cpp
onecore\base\appmodel\common\widestring.cpp
onecore\internal\base\inc\appmodel\package\ProcessorArchitecture.hpp
onecore\internal\sdk\inc\wil/Staging.h
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
opcFactory->CreateStreamOnFile( manifestPath.GetChars(), OPC_STREAM_IO_READ, NULL, FILE_ATTRIBUTE_NORMAL, &manifestStream)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, false , &file)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, true , &fileHandle)
Opening reg key HKEY_LOCAL_MACHINE\%ls to enumerate
Opening reg key HKEY_USERS\%ls to enumerate
Opening the effective stub preference key path: %ls
OpenPerUserClassesSubKey(userSid, appxMiniRepositoryPackagesSubkey, offlineMode, &packagesKey)
OpenPerUserSubKey(userClassesKeyName.GetChars(), subKey, offlineMode, registryKey)
OpenPerUserSubKey(userSid, rootKeyPath, offlineMode, &rootKey)
OpenSCManagerW
OpenSemaphoreW
OpenServiceW
Optional
optionalPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
OriginalFilename
originatingContextId
originatingContextMessage
originatingContextName
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running ApplySuccess.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Discover.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Gather.
OSDATA\Software\
OSRollbackPackages
outlook.office.com-F53E19B5_akxy2sb7nnr06
OutputDebugStringW
OverrideConfig
Overwriting unexpected previously set regions value %ls for package %ls 
p AWH
p WATAUAVAWH
p WAVAWH
p WvA>
p)W\j
p0R^G'
PA^_]
pA^_^[]
PA^_^[]
PA^A\_^]
PA_A^_
pA_A^_^]
pA_A^A\_^[]
pA_A^A]A\_^]
PA_A^A]A\_^]
Package
Package %ls destage completed with hr = 0x%x.
Package %ls does not exist in SIS. Don't carry it forward
Package %ls has an in-place update pending, can't move it away.
Package %ls is being end of lifed so its package root will be excluded
Package %ls is End Of Life and missing a backup manifest, but we could not fix this.
Package %ls is End Of Life and was missing a backup manifest, but we were able to replace the backup manifest.
Package %ls is not needed, not writing to Staged Key
Package %ls will be preserved because package registration is preserved
Package family %ls does not exist in SIS. Don't carry it forward
Package family %ls is end-of-lifed
Package family not found yet, adding new entry
Package is being end of lifed so its package root will be excluded
Package is in paused state. This package will be treated the same as if it were staged
Package is LOB and will be carried forward.
Package is not uplevel provisioned or LOB and will be carried forward. Since it's downlevel provisioned, but not uplevel provisioned implies this is an OEM package
Package is uplevel provisioned.
Package root of %ls will be excluded as it is less preferred
package->get__PackageID(&packageId)
package->get_IsFramework(&isFramework)
package->get_NeedsSingletonRegistration(&needsSingletonRegistration)
package->get_PackageFullName(&packageFullName)
package->GetPackageFamilyName(&familyName)
package->GetPackageFullName(&fullName)
package->GetPackageId(&manifestPackageID)
package->GetPackageType(&packageType)
package->GetProperties(&packageProperty)
package8->get_InstalledPath(packagePath.ReleaseAndGetAddressOf())
package8->get_IsStub(&isStub)
packageBundle->bundleFullName.SetValueFromString(fullName)
packageBundle->mainPackageFullName.SetValueFromString(fullName)
packageBundle->resourcePackageFullNames.Add(fullNameBuffer.get())
packageFamilyKey.CopyTree(nullptr, allUserApplicationsKey)
packageFamilyKey.GetUInt32ValueIfExists(s_PreferStub, &value, &valueExists)
packageFamilyKey.SetUInt32Value(s_PreferStub, downlevelPreference)
packagefamilyNameAsInternalString.Initialize( packageFamilyName, static_cast<ULONG>(wcslen(packageFamilyName)))
PackageFamilyNameFromFullName
packageFullName
packageFullNameKey.GetStringValue(s_Path, &packagePath)
packageFullNames->get_Size(&size)
packageFullNames->GetAt(index, packageFullName.GetAddressOf())
packageFullNamesToReRegister->Append(packageFullName)
packageId->get_FullName(packageFullName.GetAddressOf())
packageId->get_FullName(packageFullNameAsString.GetAddressOf())
packageInfo->get_Id(&packageId)
packageInfo->get_InstalledLocation(&installedLocation)
packageInfo->get_IsFramework(&isFrameworkValue)
packageInfoCollection->First(packageInfoIterator.GetAddressOf())
packageInfoIterator->get_Current(packageInfo.GetAddressOf())
packageInfoIterator->get_HasCurrent(&hasCurrent)
packageInfoIterator->MoveNext(&hasCurrent)
PackageInstallState
packageKey.GetStringValue(s_PackageRoot, &packageRoot)
packageKey.GetStringValue(s_Path, &packageFullPath)
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeKeyString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeNameString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeKeyString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeNameString, &value, &valueExists)
packageKey.GetStringValueIfExists(s_BundleFullName, bundleFullName, &hasBundle)
packageKey.GetUInt32Value(s_InSingleInstanceStore, &inSingleInstanceStoreValue)
packageKey.GetUInt32Value(s_InstallState, &packageInstallState)
packageKey.GetUInt32Value(s_IsFramework, &isFrameworkValue)
packageKey.GetUInt32Value(s_PackageType, &packageType)
packageKey.GetUInt32ValueIfExists(s_InstallState, &packageInstallState, &valueExists)
packageKey.GetUInt32ValueIfExists(s_IsStub, &isStubValue, &valueExists)
packageKey.SetStringValue(pathValueName, expandedPath)
packageKey.SetStringValue(s_BundleFullName, bundleName.GetChars())
packageKey.SetStringValue(s_PackageRoot, manifestPath.GetChars())
packageKey.SetStringValue(s_Path, packageFullPath)
packageKey.SetUInt32Value(s_InSingleInstanceStore, inSingleInstanceStore ? 1 : 0)
packageKey.SetUInt32Value(s_InstallState, packageInstallState)
packageKey.SetUInt32Value(s_IsFramework, isFrameworkValue ? 1 : 0)
packageKey.SetUInt32Value(s_IsStub, isStub)
packageKey.SetUInt32Value(s_PackageType, packageType)
PackageList
packageManager->FindPackagesByUserSecurityId(userSidAsInternalString, collection)
packageManager->FindUsers(packageFullName, userInfoCollection.GetAddressOf())
packageManager->SetPackageStatusBlocking(packageFullName)
packageManager->SetupOutdatedPackagesForReRegistration(userSidString.Get(), packagesToReRegister.Get())
packageManager2.As(&packageManager)
packageManager2->FindPackagesByUserSecurityIdPackageFamilyNameWithPackageTypes( userSidAsInternalString, packagefamilyNameAsInternalString, Windows::Management::Deployment::PackageTypes_Bundle, collection)
packageManifestPath->InitializeFromString(manifestPath.GetChars())
packagePath.Initialize(packageRoot.get(), packageRootLength)
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxBundleManifestRelativePath) - 1))
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxManifestRelativePath) - 1))
PackageRepositoryRoot
PackageRoot
packageRoot.SetLength(packageRootLength)
packageRootBuilder.AppendChar(L'\\')
packageRootBuilder.AppendString(package)
PackageRootFolder
Packages
packages->GetCurrent(&package)
packagesKey.Open(HKEY_LOCAL_MACHINE, effectivePackageRepositoryPackagesKeyPath, KEY_READ | KEY_WOW64_64KEY)
packagesKey.OpenSubKey(packageFullName.GetChars(), KEY_READ | KEY_WRITE, &packageKey)
packagesPathBuilder.AppendString(Common::Deployment::packagesDir)
packagesPathBuilder.AppendString(infusedAppsFolder.GetChars())
packageStatics->Find(&packages)
packageStatics->FindPackageFullNamesByUserSidAndPackageTypeAndTargetDeviceFamily( userSidAsHString.Get(), Windows::Internal::StateRepository::PackageType_Main, DEVICEFAMILYINFOENUM_WINDOWS_8X, &packageFullNames)
packageStatics->UpdateIsSingletonRegistered(packageId, false)
PackageStatus
PackagesToCheckForStagingCompletion
PackagesToCheckForStagingCompletion: %ls
packagesToCheckForStagingCompletion->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
PackagesToRemove
PackagesToReRegister
packagesToReRegister->get_Size(&vectorCount)
packageSubKey->SetValueFromString(packageFullName)
packageSubKeyBuilder.AppendChar(L'\\')
packageSubKeyBuilder.AppendString(packageFamilyName)
packageSubKeyBuilder.AppendString(packageFullName)
packageSubKeyBuilder.AppendString(packageToWrite)
packageSubKeyBuilder.AppendString(userSid)
PackageType
PackageVolumeKey
PackageVolumeName
PartA_PrivTags
pathBstr.CopyFromString(path)
pathBuilder.AppendChar('\\')
pathBuilder.AppendChar(L'\\')
pathBuilder.AppendString(&RecoveryReader::recoveryExtension)
pathBuilder.AppendString(appRepositoryExpandedPath)
pathBuilder.AppendString(autogenDirectorySubPath)
pathBuilder.AppendString(Common::Deployment::ManifestFileName.chars)
pathBuilder.AppendString(familyName)
pathBuilder.AppendString(fullName)
pathBuilder.AppendString(L"\\")
pathBuilder.AppendString(packageFullName)
pathBuilder.AppendString(path)
pathBuilder.AppendString(path->GetString())
pathBuilder.AppendString(systemMetadataDirectoryForPackage)
pathBuilder.AppendString(systemMetadataFolder)
pathBuilder.AppendString(upgradePath.GetString())
pathBuilder.AppendString(userSid)
Paused package %ls will be preserved as it will likely be the best version when it completes 
pcPZt
PerformApplySuccessPerMachineTasks(false )
PerformApplySuccessPerMachineTasks(true )
PerformApplySuccessPerUserTasks(userSidString, false )
PerformApplySuccessPerUserTasks(userSidString, true )
Performing AppxUpgradeMigration Plugin offline tasks
perUserACLPathBufferBuilder.AppendString(effectivePerUserRegistryPath)
perUserACLPathBufferBuilder.AppendString(L"USERS\\")
perUserInstalledKey.CreateSubKey(package, KEY_READ | KEY_WRITE, &perUserInstalledSubKey)
perUserInstalledSubKey.SetUInt32Value(lastReturnValueRegistryValueName, S_OK)
perUserRegistryPathBufferBuilder.AppendString(appContainerStorageRegistrySubKey)
perUserRegistryPathBufferBuilder.AppendString(registryClassesPrefix)
perUserRegistryPathBufferBuilder.AppendString(userSid)
perUserReRegistrationKey.CreateSubKey(mainPackageFullName, KEY_READ | KEY_WRITE, &perUserReRegistrationSubKey)
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
pL+x;
pL9u@tRD8
Plugin Appx key not found which should be present on up-level -- abandoning FixStateRepositoryIntegrity.
Plugin registry key after Gather:
Plugin sub key found -- we're on uplevel system during apply phase for system context. Generate MigXml for Discover.
Plugin sub key found -- we're on uplevel system during apply phase for user context. Skip running Discover.
pluginAllUserStoreKey.OpenSubKey(s_Applications, KEY_READ, &applicationsKey)
pluginAllUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE, &deprovisionedKey)
pluginAppxKey.OpenSubKey( s_StagedUserAcquired, KEY_READ, &this->pluginStagedUserAcquiredKey)
PluginExecutedInOfflineMode
PluginHasExecutedOffline
preferredMap->Insert(packageFamilyName->GetChars(), newBundleAndMainPackage.Value())
preferredMap->Insert(packageLineageName->GetChars(), currentPackage)
preferredMap->Remove(packageLineageName->GetChars())
PreferStub
PreRegisterAllInboxPackages failed 0x%x
PreRegisterAllInboxPackages()
PreRegisterAllPackages finished
PreRegistering packages in plugin Staged key
PreRegistering packages in plugin StagedUserAcquired key
PreRegistering Staged package %ls
PreRegistering uplevel image packages
PreRegisterPackagesInRegistryKey(&stagedKey, PreRegisterOptions::ApplyTrustAce)
PreRegisterPackagesInRegistryKey(&this->pluginStagedKey)
PreRegisterPackagesInRegistryKey(&this->pluginStagedUserAcquiredKey)
PreRegisterUplevelImagePackages()
PreserveMetadataForPackage(fullName)
ProcessAllBundleResourceAndOptionalPackagesUsingGatheredData()
ProcessAllMainAndFrameworkPackagesUsingGatheredData()
ProcessBundleForUserUsingGatheredData( packageKey, packageFamilyName, userSid, &bundleFullName)
processElementMethod(packageInfo.Get(), packageFullNameAsString.GetRawBuffer(nullptr))
ProcessFrameworkUsingGatheredData(packageFullName)
Processing %ls
Processing all installed packages
Processing all Packages for user %ls
Processing all user store packages
Processing appx provision XML
Processing DevMode or Inbox Package %ls for user %ls
Processing downlevel all-user framework package %ls 
Processing downlevel all-user provisioned package %ls 
Processing Package %ls
Processing package %ls for ApplyTrustLabel
Processing Package %ls for user %ls
Processing Staged package %ls for preregister
Processing Staged package %ls to copy metadata
Processing sub-key %ls
ProcessMainOrBundlePackageUsingGatheredData(packageFullName)
ProcessPackagesForUserUsingGatheredData(this->userSids.At(i)->GetChars())
ProcessPackagesToApplyUsingGatheredData
ProcessPackagesToApplyUsingGatheredData completed successfully
ProcessPackagesToApplyUsingGatheredData()
ProcessResourcePackageUsingGatheredData(packageFullName)
ProcessSingletonPackagesHelperFailed
ProductName
ProductVersion
Provisioned
provisionedAttemptedPackageFamilies->InsertIgnoreDuplicates(packageFamilyName.GetChars())
provisionedInstalledPackageFullNames->Insert(familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
provisionedPackages->GetCurrent(&package)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(bundleFullName)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(mainPackageFullName)
ProvisionSourceIsBundle
pxU>w&i
q)W\j
q*Z~:
q:_0#
q\Q17
q0R^G'
qB^Xh
QueryApplicationCapabilitiesEx
QueryPerformanceCounter
QueryServiceStatus
R!s4Z
r#fD9
RaiseException
RCV2D9
ReadAppXMigrationStoresUsingGatheredData()
reader->GetListEnumerator( ProvisionPackageList_EndOfLife, &eolPackages)
reader->GetListEnumerator( ProvisionPackageList_Provisioned, &provisionedPackages)
ReadFile
Reading Appx Migration Stores failed with 0x%x. Ignoring this error so we attempt to write migration XML.
Reading provisioning XML from location: %ls
realloc
RecursiveCopyDirectoryExceptAutogen(metadataFolderInSharedLimitedTime.GetChars(), metadataFolder.GetChars())
RecursiveCopyDirectoryExceptAutogen(srcPath.GetChars(), destPath.GetChars())
Redmond1
RegCloseKey
RegCopyTreeW
RegCreateKeyExW
RegDeleteKeyExW
RegDeleteTreeW
RegDeleteValueW
RegEnumKeyExW
RegEnumValueW
RegGetKeySecurity
RegGetValueW
Regions
Registry key value [%ls] does not exist. The package may not be fully registered yet.
Registry Package entry has invalid Path
registry.GetStringValue(s_PackageRepositoryRoot, MAX_EXTENDED_PATH, &this->packageRepository)
registry.GetStringValue(s_PackageRoot, MAX_EXTENDED_PATH, &this->singleInstanceStore)
registry.Open(HKEY_LOCAL_MACHINE, Common::Deployment::AppXRegKeyPath.chars, KEY_READ)
registry.Open(HKEY_LOCAL_MACHINE, offlineAppxRegKeyPath.GetChars(), KEY_READ)
registryKey->CreateSubKey(packageSubKey.GetChars(), KEY_READ | KEY_WRITE, subKey)
registryKey->IsNull()
registryKey->Open(HKEY_USERS, effectiveUserPath, KEY_READ | KEY_WOW64_64KEY)
registryKey->OpenSubKey(fullName, KEY_READ, &packageFullNameKey)
registryKey->OpenSubKey(subKeyName, KEY_READ, &subKey)
registryPathBuilder.AppendString(hivePrefix)
registryPathBuilder.AppendString(onlineRegistryPath)
regkey.DeleteValueIfExists(L"MaintenanceLastPerformed")
regkey.Open(HKEY_LOCAL_MACHINE, stateRepositoryRegistryStatusSubkey, KEY_READ | KEY_WRITE)
regkey.SetUInt32Value(stateRepositoryRegistryNameAutoCheckIntegrity, autoCheckIntegrityOptions_FixIntegrity)
RegOpenKeyExW
RegQueryInfoKey
RegQueryInfoKeyW
RegQueryValueExW
RegSetKeySecurity
RegSetValueExW
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
Removed deprovisioned package %ls from uplevel key.
RemoveDirectoryW
Removing uplevel provisioned unneeded packages
RepairPathValueInUserRegistryKey(userSid, keyPath, bstrExpandedSisPath.Value(), offlineMode)
Replacing bad path in reg key value [%ls] with: %ls
repositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa->CheckIntegrity(Windows::Internal::StateRepository::Management::IntegrityOptions_Fix)
repositoryManager->CheckIntegrity(options, &integrityDisposition, &countOfErrorsCorrected)
repositoryManager->Repair(Windows::Internal::StringReference(userSid == nullptr ? L"" : userSid).Get(), ((userSid == nullptr) || (userSid[0] == L'\0')) ? Windows::Internal::StateRepository::Management::RepairOptions_NoUser : Windows::Internal::StateRepository::Management::RepairOptions_NoMachine, &found, &deleted)
ResetStateRepositoryMaintenance called
ResetStateRepositoryMaintenance done
ResetStateRepositoryMaintenance()
Resource
resource
resourcePackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
result == 0
RETURN_HR_IF(%hs) failed with 0x%x
RETURN_HR_IF_FALSE(%hs) failed with 0x%x
RETURN_HR_IF_MSG(%hs) failed with 0x%x. Message is below:
RETURN_IF_FAILED(%hs) failed with 0x%x
RETURN_IF_FAILED_MSG(%hs) failed with 0x%x. Message is below:
RETURN_IF_WIN32_BOOL_FALSE(%hs) failed with 0x%x
RETURN_LAST_ERROR_IF(%hs) failed with 0x%x
RETURN_LAST_ERROR_IF_NULL(%hs) failed with 0x%x
ReturnHr
ReturnNt
RoActivateInstance
RoGetActivationFactory
RoOriginateError
rootFolderPathBstr.CopyFromString(Common::Deployment::appxDeploymentClientTaskFolder)
RoTransformError
RSDS^Bxk
RtlAcquireSRWLockExclusive
RtlAcquireSRWLockShared
RtlAllocateHeap
RtlCaptureContext
RtlCompareUnicodeString
RtlDeleteElementGenericTableAvl
RtlEnumerateGenericTableWithoutSplayingAvl
RtlFreeHeap
RtlGetDeviceFamilyInfoEnum
RtlGetVersion
RtlGetVersion failed with error code: 0x%x
RtlInitializeGenericTableAvl
RtlInitUnicodeString
RtlInsertElementGenericTableAvl
RtlIsGenericTableEmptyAvl
RtlIsStateSeparationEnabled
RtlLookupElementGenericTableAvl
RtlLookupFunctionEntry
RtlNotifyFeatureUsage
RtlNtStatusToDosErrorNoTeb
RtlReAllocateHeap
RtlRegisterFeatureConfigurationChangeNotification
RtlReleaseSRWLockExclusive
RtlReleaseSRWLockShared
RtlUnregisterFeatureConfigurationChangeNotification
RtlVirtualUnwind
S-1-0-0
S-1-1-0
S-1-15-3-1024-3635283841-2530182609-996808640-1887759898-3848208603-3313616867-983405619-2501854204
S-1-5-18
s8D8{@uXL9>u$E3
Same package was already found
SaveUpgradeDataToPluginKey()
searchPathBuilder.AppendString(L"\\*")
searchPathBuilder.AppendString(offlineSystemSisPath.GetChars())
searchPathBuilder.AppendString(this->singleInstanceStore.GetChars())
searchString.SetValueFromString(sourceDirectory)
searchStringBuilder.AppendString(L"\\*")
searchStringBuilder.AppendString(L"\\*.xml")
searchStringBuilder.AppendString(packagePath)
searchStringBuilder.AppendString(this->packageRepository.GetString())
SelectionNamespaces
SetCapacity %u
SetEntriesInAclW
SetEvent
SetFileAttributesW
SetFixStateRepositoryAlreadyExecuted()
SetLastError
SetNamedSecurityInfoW
SetPluginHasExecutedOffline succeeded for value-name: %ls.
SetPluginHasExecutedOffline()
SetPreferredBundleAndMainPackageFields(existingBundleAndMainPackage, packageFullName, isBundle, packageIsPaused, packageIsStub, true )
SetPreferredBundleAndMainPackageFields(newBundleAndMainPackage, packageFullName, isBundle, packageIsPaused, packageIsStub, false )
SetThreadpoolTimer
SetUnhandledExceptionFilter
SetupPhase
SharedLimitedTime metadata directory exists but metadata directory does not exist for %ls. Not copying files
SharedLimitedTime metadata directory exists: Preparing to copy metadata
SharedLimitedTime\
SisDirectory
sisDirectoryKey.CreateSubKey(subFolderName, KEY_READ | KEY_WRITE, &directoryKey)
sisDirectoryKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &subKey)
SisPath
Skipping AppxPreRegisterAllInboxPackages
Skipping package root folder path value not in single instance store (for example, system apps): %ls. Value length: %u
Skipping ProcessPackagesToApplyUsingGatheredData since it has already executed.
Sleep
Software
Software\
Software\Classes\ActivatableClasses
Software\Classes\AppX$
Software\Classes\Extensions
Software\Classes\Folder
Software\Classes\FolderTypes
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Mappings
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\SystemAppData
Software\Classes\PackagedCom
SOFTWARE\Microsoft\Messaging
Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Microsoft\Windows\CurrentVersion\AppHost\IndexedDB
Software\Microsoft\Windows\CurrentVersion\AppModel
Software\Microsoft\Windows\CurrentVersion\AppModel\StateChange
SOFTWARE\Microsoft\Windows\CurrentVersion\AppModel\StateRepositoryStatus
Software\Microsoft\Windows\CurrentVersion\AppSync
Software\Microsoft\Windows\CurrentVersion\Appx
Software\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore
Software\Microsoft\Windows\CurrentVersion\AppX\ByteCodeQueue
Software\Microsoft\Windows\CurrentVersion\Appx\PackageVolumes
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Alarm
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\BackgroundCapability
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Badge
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Tile
Software\Microsoft\Windows\CurrentVersion\DeviceCapabilities
Software\Microsoft\Windows\CurrentVersion\Explorer\AutoplayHandlers\Handlers
Software\Microsoft\Windows\CurrentVersion\PushNotifications
Software\RegisteredApplications
source.OpenSubKey(subKeyName, KEY_READ, &sourceSubKey)
sourceBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
sourceBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
sourceBackupManifestFilePathBuilder.AppendString(manifestPathBuffer.GetChars())
SRCheckIntegrity
srCheckIntegrity(options, &disposition)
SRImportPackageUserStatus
srImportPackageUserStatus(userSidString, userPath.GetChars(), &numImported, &numFailedToImport)
Staged
stagedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, stagedSD)
stagedKey.Open( HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ | KEY_WRITE | WRITE_DAC)
stagedKey.Open(HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ)
StagedUserAcquired
Starting AppxPreRegisterAllInboxPackages
Starting AppxUpgradeMigration Plugin during Apply Success
Starting AppxUpgradeMigration Plugin during Discover for %ls
Starting AppxUpgradeMigration Plugin during Gather
Starting EnsureAppRootPermissions
Starting EnsureRegistryKeyPermissions
Starting EnumAndAddPackagesNotKnownToCapAuth
Starting FixStateRepositoryIntegrity.
Starting ImportPackageUserStatusToStateRepository
Starting ProcessPackagesToApplyUsingGatheredData
Starting RepairBadPathsInHKU
Starting RepairPackageRepositoryKeyInHKLM
Starting RepairPackageRootFolderPathInRepositoryRegistryKey
Starting RepairPathValueInUserRegistryKey. Inspect all immediate sub-keys under HKEY_USERS\%ls%ls and repair key values containing bad paths
Starting RepairStateRepository for %ls.
StateChange
StateRepository
staterepository-machine.srd
stringArray->Add(packageSubKey)
StringCchCopy(packageFullNameChunk, packageFullNameChunkLength, trimmedChunk)
StringCchLengthW(expandedPath, Common::String::MaxLength, &expandedPathLength)
StringCchLengthW(expandedSisPath, Common::String::MaxLength, &sisPathLength)
StringCchPrintfW(pathname.get(), pathnameLength, L"%ls\\%ls%ls", workingDir.get(), subdir, filename)
StringFileInfo
stringVector->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
StubPreference
subFolderActionFunction(findFileData.cFileName, fullFilePath.GetChars())
subKey->SetStringValue(AppxAllUserStore::regValuePath, *packagePath)
Successful delay-load of GetStagedPackagePathByFullName
Successfully finished processing all packages during AppxUpgradeMigration ApplySuccess
Successfully finished processing all packages during AppxUpgradeMigration Discover
Successfully finished processing all users and packages during AppxUpgradeMigration Gather
SVWAVH
system
SYSTEM\Setup\Upgrade\Appx
systemMetadataDirectoryForPackage.IsNull()
t"@8=
t$ E3
t$ UWAVH
t$ UWAWH
t$ WATAUAVAWH
t$ WAVAWH
t$ WH
t$`uFE3
t$0E3
T$0H+
T$8L+
T$dfD
t$hL9|$`u
T$PE3
t$PE3
T$PE3
T$PL;
t$XE3
t%H9p
t(D8-
t(D8%#
t(D8=(b
t,D8=
t/HcL$$A
t[f9+tV
t_L9h
t`H!\$HH
t+I9^
t0E9&
t9L9h
tAfA9(t;H
tAH9X
targetBackupManifestFilePathBuilder.AppendChar('\\')
targetBackupManifestFilePathBuilder.AppendString(appRepositoryExpandedPath)
targetBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
targetBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
taskFolder->DeleteTask(taskNameBstr, 0)
taskNameBstr.CopyFromString(Common::Deployment::appInstallerUpdateAllTaskName)
taskService->Connect(variantNull, variantNull, variantNull, variantNull)
taskService->GetFolder(rootFolderPathBstr, &taskFolder)
TerminateProcess
tgfD9e
Thales TSS ESN:7BF1-E3EA-B8081%0#
this->allUserFrameworkSet.InsertIgnoreDuplicates(subKey)
this->allUserPackages.InsertIgnoreDuplicates(subKey)
this->appModelRuntimeApisetHandle
this->AppxPreRegisterAllInboxPackages
this->AppxPreRegisterPackage
this->context->ExpandEnvironmentVariables(bstrPath, &bstrExpandedPath)
this->context->ExpandEnvironmentVariables(bstrSisPath, &bstrExpandedSisPath)
this->context->get_WorkingDir(&workingDir)
this->context->GetOfflineFileLocation( bstrOnlineFilePath.Value(), &bstrOfflineFilePath)
this->context->GetOfflineRegistryLocation( bstrOnlineRegistryPath.Value(), &bstrOfflineRegistryPath)
this->deploymentClientDllModule
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMessagingEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMobilePlansEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(familyName)
this->excludeFilesSet.InsertIgnoreDuplicates(filePath.GetChars())
this->excludeInfusedAppsFolderSet.InsertIgnoreDuplicates(packageFullPath.GetChars())
this->excludePackageFullNameSet.InsertIgnoreDuplicates(fullName)
this->excludePackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())
this->GetContext()->get_UserSidString(&userSid)
this->GetContext()->GetOfflineStatus(&offlineExecution)
this->GetStagedPackagePathByFullName
this->includeMetadataSet.InsertIgnoreDuplicates(metadataPath.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(familyName.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->noReRegisterOnUpgrade
this->oemProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->pluginAllUserStoreKey.CopyTree(nullptr, allUserStoreKey)
this->pluginAllUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &this->pluginDeprovisionedKey)
this->pluginAllUserStoreKey.CreateSubKey( s_DownlevelInstalled, KEY_READ | KEY_WRITE, &this->pluginDownlevelInstalledKey)
this->pluginAllUserStoreKey.CreateSubKey( s_EndOfLife, KEY_READ | KEY_WRITE, &this->pluginEndOfLifeKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Staged, KEY_READ | KEY_WRITE, &this->pluginStagedKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Upgrade, KEY_READ | KEY_WRITE, &this->pluginUpgradeKey)
this->pluginAllUserStoreKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserInstalledKey)
this->pluginAllUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &this->pluginStagedKey)
this->pluginApplicationsKey.CreateSubKey( packageSubKey.GetChars(), KEY_ALL_ACCESS, &mainPackageKey)
this->pluginApplicationsKey.OpenSubKey(subKey, KEY_READ, &packageFamilyKey)
this->pluginAppxKey.Create(HKEY_LOCAL_MACHINE, pluginRegistryKeyPath, KEY_ALL_ACCESS)
this->pluginAppxKey.CreateSubKey( allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &this->pluginAllUserStoreKey)
this->pluginAppxKey.CreateSubKey( s_Applications, KEY_READ | KEY_WRITE, &this->pluginApplicationsKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToCheckForStagingCompletion, KEY_READ | KEY_WRITE, &this->pluginPackagesToCheckForStagingCompletionKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToRemove, KEY_READ | KEY_WRITE, &this->pluginPackagesToRemoveKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToReRegister, KEY_READ | KEY_WRITE, &this->pluginPackagesToReRegisterKey)
this->pluginAppxKey.CreateSubKey( s_StagedUserAcquired, KEY_READ | KEY_WRITE, &this->pluginStagedUserAcquiredKey)
this->pluginAppxKey.CreateSubKey(s_Applications, KEY_READ | KEY_WRITE, &applicationsKey)
this->pluginAppxKey.CreateSubKey(s_DownlevelGather, KEY_ALL_ACCESS, &this->pluginDownlevelGatherKey)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, &this->packageRepository)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, backupManifestDir)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, &this->singleInstanceStore)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, packageRoot)
this->pluginAppxKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
this->pluginAppxKey.Open(HKEY_LOCAL_MACHINE, effectivePluginPath, KEY_ALL_ACCESS)
this->pluginAppxKey.OpenSubKey(s_Applications, KEY_READ, &applicationsKey)
this->pluginAppxKey.OpenSubKey(s_DownlevelGather, KEY_READ, &this->pluginDownlevelGatherKey)
this->pluginAppxKey.SetBinaryValue(migXmlRegValueName, migXml, (SysStringLen(migXml) + 1) * sizeof(OLECHAR))
this->pluginAppxKey.SetStringValue(s_DownlevelPackageRepositoryRoot, this->packageRepository.GetChars())
this->pluginAppxKey.SetStringValue(s_DownlevelPackageSisRoot, this->singleInstanceStore.GetChars())
this->pluginAppxKey.SetUInt32Value(s_ProcessPackagesToApplyUsingGatheredData, 1)
this->pluginAppxKey.ValueExists(s_ProcessPackagesToApplyUsingGatheredData, &valueExists)
this->pluginDownlevelGatherKey.CreateSubKey(allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &pluginAllUserStoreKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_BundleManifestInfo, KEY_READ | KEY_WRITE, &bundleInfoRootKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeFiles, KEY_READ | KEY_WRITE, &excludeFilesKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeInfusedApps, KEY_READ | KEY_WRITE, &excludeInfusedAppsKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_InstalledPackages, KEY_READ | KEY_WRITE, &installedPackagesKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_PackageInstallState, KEY_READ | KEY_WRITE, &installStateRootKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_SisDirectory, KEY_READ | KEY_WRITE, &sisDirectoryKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_StateChange, KEY_READ | KEY_WRITE, &stateChangeKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_StubPreference, KEY_READ | KEY_WRITE, &stubPreferenceKeyCopy)
this->pluginDownlevelGatherKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &userKey)
this->pluginDownlevelGatherKey.OpenSubKey(allUserStoreRegistryKeyName, KEY_READ, &allUserStoreKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_BundleManifestInfo, KEY_READ, &bundleInfoRootKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_InstalledPackages, KEY_READ, &installedPackagesKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateRootKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_SisDirectory, KEY_READ, &sisDirectoryKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_StateChange, KEY_READ, &stateChangeKey)
this->pluginDownlevelGatherKey.OpenSubKey(userSid, KEY_READ, &userKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeFiles, KEY_READ, &excludeFilesKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeInfusedApps, KEY_READ, &excludeInfusedAppsKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_PackageInstallState, KEY_READ, &installStateRootKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_StubPreference, KEY_READ, &stubPreferenceRootKey)
this->pluginPackagesToCheckForStagingCompletionKey.CreateSubKey( packageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( bundleFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( mainPackageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( resourcePackageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.KeyExists(fullName, &isPackageToBeRemoved)
this->pluginPackagesToReRegisterKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserReRegistrationKey)
this->stagedOnlyManifestPackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->uplevelProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(familyName.GetChars())
this->uplevelProvisionedPackageMap.Insert(familyNameBuffer.GetChars(), newEntry.get())
this->userSids.Add(userSid)
threadId
tjD9|$Xvc
tjH9X
TlP0X
tOD8}gtBH
TotalTimeTaken
Translation
ty@8=
tyfD9"tsH
u@fD9u0A
U0S0Q
UATAUAVAWH
UAUAVH
UAVAWH
UAVAWI
ubH!]@H
uHfD9u8A
Unable to clean-up orphan packages: 0x%x
Unable to clean-up SystemApps migrated to FOD: 0x%x
Unable to clear IsSingletonRegisteredFlags: 0x%x
Unable to copy backup manifest for end of life packages if necessary: 0x%x
Unable to copy metadata: 0x%x
Unable to DeleteOSRollbackPackagesRegistry: 0x%x
Unable to Mark up-level provisioned paused packages as staged: 0x%x
Unable to pre register packages: 0x%x
Unable to re index packages for feature light up: 0x%x
Unable to Remove up-level provisioned unneeded packages: 0x%x
Unable to repair bad path values in HKEY_USERS: 0x%x
Unable to repair Package Repository registry key values for packages: 0x%x
Unable to repair PackageRootFolder values for packages: 0x%x
Unable to repair StateRepository for %ls: 0x%x
Unable to SavePackageListFromFileToRegistry: 0x%x
Unable to set security descriptor for all user store key with 0x%x
Unable to set security descriptor for deprovisioed key with 0x%x
Unable to set security descriptor for end of life key with 0x%x
Unable to set security descriptor for staged key with 0x%x
Unable to set up packages for re-registration: 0x%x
Unable to write all user store keys 0x%x
Unexpected - bundle full name already added for the family. Existing bundle full name: %ls, full name to be added: %ls
Unexpected - main full name already added for the family. Existing main full name: %ls, full name to be added: %ls
Unexpected - uplevel provisioned package family does not have main and/or bundle package. Package family name: %ls, number of resource packages: %u
Unexpected failure from ExpandEnvironmentStrings on string %ls. Buffer size %u characters. Required size %u characters
Unexpected failure from ExpandEnvironmentVariables on string %ls
UnhandledExceptionFilter
unknown
Unnecessary. Skipping EnumAndAddPackagesNotKnownToCapAuth
UpdateAppInstallerScheduledTask()
UpdateProcThreadAttribute
Upgrade
upgradeKey.Open(HKEY_LOCAL_MACHINE, upgradePath.GetChars(), KEY_READ | KEY_WRITE)
upgradeKey.OpenSubKey(userSid, KEY_READ, &userSidKey)
upgradeKey.SetUInt64Value(timeElapsedValueName, timeElapsed)
upgradeKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
Up-level provisioned package %ls is less preferred than existing package %ls. Writing it to PackagesToRemove Key
Uplevel Provisioned package: %ls found in appxprovisioning.xml
uplevelPackageToDelete->SetValueFromString(fullNameKey)
uplevelStubPreferenceKey.CreateSubKey(packageFamilyName.GetChars(), KEY_READ | KEY_WRITE, &packageFamilyKey)
Use get_InstalledLocation to get package root
userClassesKeyNameBuilder.AppendString(registryClassesPrefix)
userClassesKeyNameBuilder.AppendString(userSid)
userInfo.Get()->get_InstallState(&installStateValue)
userInfo->get_UserSecurityId(userInfoSid.Address())
userInfoCollection->First(userInfoIterator.GetAddressOf())
userInfoIterator->get_Current(userInfo.GetAddressOf())
userInfoIterator->get_HasCurrent(&hasCurrent)
userInfoIterator->MoveNext(&hasCurrent)
userInfoSid.GetLpcwstr(&userAsLpcwstr)
userKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
userKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
userPathBuilder.AppendString(appxMiniRepositoryPackagesSubkey)
userPathBuilder.AppendString(registryClassesPrefix)
userPathBuilder.AppendString(subKey)
userPathBuilder.AppendString(userSidKeyName)
userPathBuilder.AppendString(userSidString)
USERS\
userSid->SetValueFromString(subKey)
userSidAsInternalString.Initialize(userSid, static_cast<ULONG>(wcslen(userSid)))
userSidKey.KeyExists(packageFullName, isPackageEndOfLife)
USVWATAUAVAWH
USVWAVH
USWATAUAVAWH
UVATAVAWH
UVWATAUAVAWH
UVWATAVH
UVWAVAWH
UWATAUAVH
UWATAUAWH
UWATAVAWH
UWATH
UWAUAVAWH
UWAVH
UWAWH
uyL7j
v$A+I
v~Bpd
valueBuffer.SetCapacity(valueBufferLength)
valueNameBuilder.AppendString(pluginHasExecutedOfflineValueName)
valueNameBuilder.AppendString(userSid ? userSid.get() : L"")
VarFileInfo
VerQueryValueW
version="1.0" encoding="utf-8"
versionData.IsNull()
VS_VERSION_INFO
VWATAVAWH
VWAUAVAWH
VWAVH
WaitForSingleObject
WaitForSingleObjectEx
WaitForThreadpoolTimerCallbacks
Washington1
WATAUAVAWH
WATAVH
WAVAWH
wcscmp
wcsrchr
wcsstr
wilResult
WilStaging_02
Windows.Foundation.Collections.IIterator`1<String>
Windows.Foundation.Collections.IVector`1<String>
Windows.Foundation.Collections.IVectorView`1<String>
Windows.Internal.StateRepository.Management.RepositoryManager
Windows.Internal.StateRepository.Package
Windows.Management.Deployment.Internal.PackageManagerInternal
Windows.Management.Deployment.PackageManager
Windows.MiracastView_6.3.0.0_neutral_neutral_cw5n1h2txyewy
Windows::Foundation::ActivateInstance( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Management_Deployment_Internal_PackageManagerInternal).Get(), &packageManager)
Windows::Foundation::ActivateInstance( Windows::Internal::StringReference(RuntimeClass_Windows_Internal_StateRepository_Management_RepositoryManager).Get(), &repositoryManager)
Windows::Foundation::ActivateInstance(acid.Get(), &inspectable)
Windows::Foundation::ActivateInstance(strActivatableClassId.Get(), &packageManager)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToCheckForStagingCompletion)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToReRegister)
Windows::Foundation::GetActivationFactory( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Internal_StateRepository_Package).Get(), &packageStatics)
Windows::Foundation::GetActivationFactory(acid.Get(), &packageStatics)
WindowsCreateString
WindowsCreateStringReference
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
WindowsStringHasEmbeddedNull
WriteAllProvisionedUninstalledPackageKeysToListUsingGatheredData( userSid, provisionedInstalledPackageFullNames, &provisionedUninstalledPackageFullNames)
WriteDeprovisionListToPluginAllUserStoreUsingGatheredData()
WriteFile
WriteOutRegistryIncludeRules( MigXmlRules::perMachineRegistryRules, ARRAYSIZE(MigXmlRules::perMachineRegistryRules), true, xmlWriter)
WriteOutRegistryIncludeRules( MigXmlRules::perUserRegistryRules, ARRAYSIZE(MigXmlRules::perUserRegistryRules), false, xmlWriter)
WritePackageAlreadyInstalledForUserKey(userSid, fullNameToWrite)
WritePackageAlreadyInstalledForUserKey(userSid, package)
WritePackageBundleToRemoveKey(uplevelProvisionedPackageBundle)
WritePackageRegistryKey( packageElement->GetKey(), bundleFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageElement->GetKey(), mainPackageFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageFamilyName, bundleFullName->GetChars(), userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
WritePackageRegistryKey( packageFamilyName, fullNameToWrite, userSid, &this->pluginUpgradeKey, s_Upgrade, &createdKey)
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageFamilyName.GetChars(), packageFullName, userSid, &this->pluginStagedUserAcquiredKey, s_Staged)
WritePackageRegistryKey( packageFullName, userSid, &this->pluginEndOfLifeKey, s_EndOfLife)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled, packageRoot.GetString(), &downlevelInstalledKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginUpgradeKey, s_Upgrade, packageRoot.GetString(), &upgradeKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, registryKey, keyName, manifestPath.GetString(), createdKey)
WritePackagesToCheckPostUpgradeToSetupKeyUsingGatheredData()
Writing %ls Key %ls
Writing %ls Key %ls\%ls
Writing Applications Key %ls
Writing bundle package full name to PackagesToRemove Key: %ls
Writing Downlevel all-user key %ls to uplevel key
Writing main package full name to PackagesToRemove Key: %ls
Writing out to exclude file %ls in XML Writer.
Writing out to include directory %ls in XML Writer.
Writing out to include directory %ls, file %ls in XML Writer.
Writing out to include registry key %ls in XML Writer.
Writing out to include registry key %ls, value %ls in XML Writer.
Writing out to merge registry key %ls in XML Writer.
Writing out to merge registry key %ls, value %ls in XML Writer.
Writing out to move directory %ls to backup folder in XML Writer for OS downgrade.
Writing out to registry %ls in XML Writer.
Writing Package to PackagesToCheckForStagingCompletion Key: %ls
Writing resource package full name to PackagesToRemove Key: %ls
Writing up-level provisioned deprovisioned Package to PackagesToRemove Key: %ls
x AVH
x UATAUAVAWH
x UAVAWH
X0V0T
x86a64
XA_A^_^][
xmD8|$@ufD
xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage"
xSu$W
